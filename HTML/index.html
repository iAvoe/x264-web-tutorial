<!DOCTYPE html>
<html lang='zh-hans'>
	<head>
        <meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1">
        <!-- favicon -->
        <link rel="icon" href="./files/favicon.svg" type="image/svg+xml">
        <!-- JavaScript Codes -->
        <script src="./files/tutorial.js" defer></script>
        <!-- Basic MathJax Javascript -->
        <script src="./files/mathJax3-tex-svg.js" defer></script>
        <!-- Custom CSS Codes <link rel="stylesheet" href="./files/desktopContainer.css"> -->
        <link rel="preload" href="./files/tutorial.css" as="style">
        <link rel="stylesheet" href="./files/tutorial.css">
        
        <title>x264 教程 HTML 完整版</title>
	</head>
	<body class="text-gray-main">
        <div class="container-title">
            <h1>x264 教程<span class="text-blue-emph"> HTML 完整版</span></h1>
            <p>欢迎阅读！本教程仅算盲人摸象的业余分析，仅具备业余参考价值。若有什么不会的可以加群<a href='https://jq.qq.com/?_wv=1027&k=5YJFXyf'>691892901</a>。</p>
            <!-- x265 教程副本，更改需手动同步 { -->
            <h2>地图</h2>
            <ol class="font-monospace">
                <li>
                    <a href="../../x264-web-tutorial/HTML/index.html" class="disabled">x264 教程网页版（你在这里）</a>
                    <ul class="text-xs">
                        <li>基础：<a class="toSelf" href="#h2-1">封装/解封装</a>，
                            <a class="toSelf" href="#h2-2">编解码过程</a>，
                            <a class="toSelf" href="#h2-3">视频结构</a>
                        </li>
                    </ul>
                    <ul class="text-xs">
                        <li>编码：<a class="toSelf" href="#h2-4">前瞻进程</a>，
                            <a class="toSelf" href="#h2-5">动态预测</a>，
                            <a class="toSelf" href="#h2-6">动态搜索</a>，
                            <a class="toSelf" href="#h2-7">动态补偿</a>，
                            <a class="toSelf" href="#h2-8">变换量化</a>，
                            <a class="toSelf" href="#h2-9">率控制模式</a>，
                            <a class="toSelf" href="#h2-10">自适应量化</a>，
                            <a class="toSelf" href="#h2-11">模式决策、环路滤镜</a>，
                            <a class="toSelf" href="#h2-12">优化量化策略</a>，
                            <a class="toSelf" href="#h2-13">熵编码</a>，
                            <a class="toSelf" href="#h2-14">优化熵编码</a>，
                            <a class="toSelf" href="#h2-15">色彩信息</a>
                        </li>
                    </ul>
                    <ul class="text-xs">
                        <li>附录：
                            <a class="toSelf" href="#h2-15">预设参数</a>，
                            <a class="toSelf" href="#h2-16">线程控制</a>，
                            <a class="toSelf" href="#h2-17">工具下载</a>
                        </li>
                    </ul>
                </li>
                <li><a href="../../x265-web-tutorial/HTML/index.html">x265 教程网页版</a></li>
                <li><a href="../../av1-web-tutorial/HTML/index.html">AV1 教程网页版</a></li>
                <li>附录 α：
                    <a href="https://www.nazorip.site/archives/44/">QAAC 音频压缩教程</a> 或 <a href="https://github.com/iAvoe/QAAC-Tutorial-Standalone/blob/master/%E6%95%99%E7%A8%8B.md">Github 副本</a>
                    <ul class="text-xs">
                        <li>下载安装，用例，Pipe 导入，流格式，封装格式，多声道编辑，压缩强度与占用，章节处理，缓入缓出，音频标识，音频编辑，滤镜，已知报错，多参数储存和调用，采样率的选择，采样率的验证</li>
                    </ul>
                </li>
                <li>附录 β：<a href="https://nazorip.site/archives/334/">x264，libx264，x265，libx265 压制教程急用版</a></li>
                <li>附录 γ：<a href="https://nazorip.site/archives/169/">ffprobe 教程</a> 或 <a href="https://github.com/iAvoe/FFprobe-Tutorial-Standalone/blob/master/%E6%95%99%E7%A8%8B.md">Github 副本</a></li>
                <li>附录 δ：<a href="https://nazorip.site/archives/1068/">ffprobe + Excel 绘制码率曲线，帧类型饼图</a></li>
                <li>
                    附录 ε：<a href="../../deint-ivtc-web-tutorial/HTML/index.html">交错转逐行与 IVTC 处理</a>
                    <ul class="text-xs">
                        <li>逐行与交错扫描，帧率与场率，仅交错，A:B Pulldown / telecine，2:2:2:4，3:2:3:2，Euro-pulldown，0.5:0.5，特殊情况，去交错的算法与滤镜，IVTC 滤镜用例，p/c/n/u/b，AviSynth 例，TFM-TDecimate 例，VapourSynth 例</li>
                    </ul>
                </li>
                <li>附录 ζ：<a href="../../img-sequence-enc-web-tutorial/HTML/index.html">图像序列的处理</a></li><!-- 后续顺序：η θ ι κ λ μ -->
                <li>相关：<a href="https://nazorip.site/archives/1052/">mpv 播放器的安装与设置</a></li>
            </ol>
            <h3>打印支持</h3>
            <button type="button" class="border-main rounded-3 ms-1 px-1" onclick="toggleCollapseAll()">1/5. 点击同步展开/折叠所有内容</button>
            <button type="button" class="border-main rounded-3 ms-1 px-1" onclick="printMode(printT, printC)">2. 点击进入文档的打印模式排版</button>
            <button type="button" class="border-main rounded-3 ms-1 px-1" onclick="window.print()">3. 点击打印</button>
            <p class="font-monospace px-1">推荐设置：彩色模式、不打印背景、0.04 英寸边距、打印页眉页脚</p>
            <button type="button" class="border-main rounded-3 ms-1 px-1" onclick="printModeOff(printT, printC, widthOffset)">4. 点击退出打印排版</button>
            <button type="button" class="border-main rounded-3 ms-1 px-1" onclick="toggleCollapseAll()">1/5. 点击同步展开/折叠所有内容</button>
            <!-- } -->
            <p>点击图片即可轮询三种图片大小。窗口宽度大于窗口高度则切换到宽屏/桌面端/平板电脑排版，否则切换到窄屏/移动端排版。</p>
            <p>安卓 12 或更高版本中，如 Edge，Brave，Kiwi，Arc，Dragon，Opera 的 Chromium 内核网页浏览器有着中文字体过细的显示问题（谷歌早已知晓却从未修复）建议使用 Firefox 以确保舒适的观看体验。</p>
        </div>
        <div class="container-mobile rounded-9 border-main">
            <h2 id="h2-1">必备常识</h2>

            <h3>什么是电脑</h3>
            <p>早期的电脑由中央处理器（CPU），内存（RAM、ROM）和一些专用芯片组成。芯片之间通过 PCB 板上的总线 Bus 互联，从而完成各种计算任务。这种 PCB 板同时负责了一套独立电脑系统的供电、信号、扩展等特性，而被特指为主板 Mainboard 或母板 Motherboard。随着技术发展，CPU 的结构和功能被优化，出现了多核心、独立缓存、共享缓存、64 bit 寄存器（相对于 8、16、32 bit）、以及更快更通用的总线（内存总线、USB、PCIE、SATA）、ROM 演化为 BIOS。电脑的外设也更加丰富，例如鼠标，高清显示器，独立显卡等。这些设备在不同功耗、便携性等限制条件下，从原来的大型机、小型机演化出了服务器、工作站、个人电脑、笔记本、智能手机、平板电脑/掌机等统称为电脑的设备。</p>

            <h3>电脑的性能</h3>
            <p>主要看两方面：处理速度（算力）、数据传输速度（带宽）和响应速度（延迟）。例如在看视频时，即使 CPU 自身不费力，单是网络或硬盘的带宽没跟上视频的码率带宽，画面便会卡顿。这种卡顿虽然是性能问题，却与 CPU 自身无关。</p>
            <p>数据与 CPU 核心的距离会产生巨大的延迟差异。这些延迟往往会因为同步，分阶段读取，安全验证检查等行为而积微成著，变得显而易见：</p>
            <table class="table-center text-smaller">
                <thead>
                    <tr>
                        <th class="px-1">数据位置</th>
                        <th class="px-1">读取 CPU 周期</th>
                        <th class="px-1">估计用时</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td class="px-1 align-items-center">L1 缓存</td>
                        <td class="px-1 border-left t-align-right">3</td>
                        <td class="px-1 border-left t-align-right">1 ns</td>
                    </tr>
                    <tr>
                        <td class="px-1 align-items-center">L2 缓存</td>
                        <td class="px-1 border-left t-align-right">10~20</td>
                        <td class="px-1 border-left t-align-right">3~7 ns</td>
                    </tr>
                    <tr>
                        <td class="px-1 align-items-center">L3 缓存</td>
                        <td class="px-1 border-left t-align-right">30~70</td>
                        <td class="px-1 border-left t-align-right">10~25 ns</td>
                    </tr>
                    <tr>
                        <td class="px-1 align-items-center">内存</td>
                        <td class="px-1 border-left t-align-right">180~360</td>
                        <td class="px-1 border-left t-align-right">60~120 ns</td>
                    </tr>
                    <tr>
                        <td class="px-1 align-items-center">固态硬盘</td>
                        <td class="px-1 border-left t-align-right">240,000~900,000</td>
                        <td class="px-1 border-left t-align-right">80~300 μs</td>
                    </tr>
                    <tr>
                        <td class="px-1 align-items-center">机械硬盘</td>
                        <td class="px-1 border-left t-align-right">41,000,000</td>
                        <td class="px-1 border-left t-align-right">14 ms</td>
                    </tr>
                    <tr>
                        <td class="px-1 align-items-center">互联网</td>
                        <td class="px-1 border-left t-align-right">240,000,000</td>
                        <td class="px-1 border-left t-align-right">80 ms</td>
                    </tr>
                </tbody>
            </table>

            <h3>什么是数据 Data</h3>
            <p>数据的定义很宽泛，例如一句话就是一段数据。计算机上的数据由电信号构成，分为模拟（电压代表大小）和数字（0、1 代表开关）两种。通过将计算机编程，人们根据不同的 0、1 长度以及组合，为 CPU 定义了操作内存、硬盘等存储设备的（读写）能力，从而使得更上层的操作系统和程序能够定义和使用更抽象化的数据（如坐标，像素值）等形式，才得以让电脑显示画面，播放视频。</p>

            <h3>元数据 Metadata</h3>
            <p>描述数据的数据，例如零食的包装袋上会印有零食的参考图和名称。如果所有的包装都是白色，那么用户就无法找到想吃的零食。而电脑只能根据每个格式元数据（一般为文件后缀名）预设的“默认程序”来打开视频文件（设置错误时，也强行让设定的程序打开），而视频播放器也需要编码格式、亮度、对比度、帧率等元数据才能正确的播放视频。</p>

            <h3>编解码</h3>
            <ul class="overflow-auto">
                <li><b>编码 Encoding</b>：是数据格式的转换。压缩是编码的一种形式</li>
                <li><b>解码 Decoding</b>：是将被压缩的信号还原或播放的解压缩。一般来说，压缩程度越高，解码速度越慢</li>
                <li><b>软解 Software Decoding</b>：使用通用电路播放流文件，通常具有更高的兼容性，更高的能耗/发热</li>
                <li><b>硬解 Hardware Decoding</b>：使用专用电路替代软解，通常具有更低的兼容性，更低的能耗/发热
                    <ul class="text-gray-side">
                        <li>例如：libmxv，opencl，MMAL，direct3D</li>
                    </ul>
                </li>
                <li><b>软编 Software Encoding</b>：使用通用电路运行算法逻辑编码流文件，通常具有更完整的压缩功能但速度较慢，能耗/发热较高，同码率下的画质更高
                    <ul class="text-gray-side">
                        <li>运行时占用 CPU 核心、GPU CUDA/ROCm/OpenCL 通用计算单元、或高端采集卡中的 FPGA 核心</li>
                    </ul>
                </li>
                <li><b>硬编 Hardware Encoding</b>：使用专用电路编码流文件，通常具有较少的功能但速度更快，发热更低
                    <ul class="text-gray-side">
                        <li>常见的有 NVENC，MMF/Venus，Intel-QSV，AMD-AMF，Elgato</li>
                    </ul>
                </li>
            </ul>

            <h3>封装与解封装——(De-)multiplex</h3>
            <ul class="overflow-auto">
                <li>类似于 .zip .rar 文件将多个文件（视频，音频，字幕，字体）合并为一个文件的功能</li>
                <li>信号处理中，电台将多路音频流封装为一段模拟信号，接收端通过调整接收频率来接收其中一路信号，每路信号占据一定的频宽/带宽</li>
            </ul>
            <p>封装文件记录了视频帧率、音视频同步、色彩标识等关键元数据，播放器根据它们选择和配置解码器。常见的封装文件有：</p>
            <table class="table-center text-smaller">
                <thead>
                    <tr class="t-invert-dark">
                        <th>📦格式（全称）</th>
                        <th>用途</th>
                        <th>特点</th>
                    </tr>
                </thead>
                <tbody>
                    <tr class="border-bottom">
                        <th class="px-1 t-light-gray">MP4（MPEG-4 Part 14）</td>
                        <td class="px-1">网络与本地播放</td>
                        <td class="t-light-gray">
                            <ul>
                                <li>兼容性广，几乎所有设备和平台都支持</li>
                                <li>压缩元数据，进一步缩小文件体积</li>
                                <li>支持主要的视频、音频格式，部分字幕格式</li>
                                <li>不支持特效字幕（如 ASS/SSA）</li>
                                <li>整个文件写完后才统计并写入元数据，因此不适合录制（录制程序崩溃后整个视频损坏）</li>
                            </ul>
                        </td>
                    </tr>
                    <tr class="border-bottom">
                        <th class="px-1 t-light-gray">MKV（Matroska Multimedia Container）</td>
                        <td class="px-1">本地播放、多音轨/多字幕内容、实时录制</td>
                        <td class="t-light-gray">
                            <ul>
                                <li>轨道数量无限制</li>
                                <li>各种现存与未来的视频、音频、字幕格式</li>
                                <li>支持逐段存储元数据，录制程序崩溃后只有最后一段内容会损坏，因此适合录制</li>
                                <li>Adobe Premiere、After Effects、Media Encoder、Audition 版本 25.2 添加了原生支持</li>
                                <li>网络播放兼容性差</li>
                            </ul>
                        </td>
                    </tr>
                    <tr class="border-bottom">
                        <th class="px-1 t-light-gray">MOV（QuickTime File Format）</td>
                        <td class="px-1">本地播放、视频编辑</td>
                        <td class="t-light-gray">
                            <ul>
                                <li>用于苹果公司软硬件生态，以及其私有的视音频格式（如 ProRes）</li>
                                <li>Adobe Premiere 等专业软件长期支持</li>
                                <li>通常文件较大，但质量较高</li>
                            </ul>
                        </td>
                    </tr>
                    <tr class="border-bottom">
                        <th class="px-1 t-light-gray">M4A（MPEG-4 Audio）</td>
                        <td class="px-1">纯音频存储、音乐播放</td>
                        <td class="t-light-gray">
                            <ul>
                                <li>专门用于音频的 MPEG-4 格式</li>
                                <li>支持多种音频编解码器（如 AAC、ALAC）</li>
                                <li>支持封装封面图片和元数据</li>
                            </ul>
                        </td>
                    </tr>
                    <tr class="border-bottom">
                        <th class="px-1 t-light-gray">FLV（Flash Video）</td>
                        <td class="px-1">网络与本地播放、实时录制</td>
                        <td class="t-light-gray">
                            <ul>
                                <li>简单轻量，适合网络传输</li>
                                <li>由于结构简单，因此在录制程序崩溃后几乎无损</li>
                                <li>随着 2020 年底 Flash 的淘汰而退出主流</li>
                                <li>视频、音频格式最高只支持到 AVC、AAC，但也有一些扩展支持 H.265，被 HLS（M3U+TS）和 MP4 流取代</li>
                            </ul>
                        </td>
                    </tr>
                    <tr class="border-bottom">
                        <th class="px-1 t-light-gray">M3U/M3U8（MPEG URL Playlist）</td>
                        <td class="px-1">定义播放列表（本地媒体、流媒体，如 HTTP Live Streaming）</td>
                        <td class="t-light-gray">
                            <ul>
                                <li>文本列表，HLS 客户端根据它从 CDN、P2P 下载并按顺序排列 TS 封装的小片段</li>
                                <li>部分 HLS 客户端中有缓存 TS 并上传给其它客户端的扩展实现</li>
                                <li>M3U8 使用 UTF-8 文本编码，是前者的扩展版本</li>
                            </ul>
                        </td>
                    </tr>
                    <tr class="border-bottom">
                        <th class="px-1 t-light-gray">TS（MPEG Transport Stream）</td>
                        <td class="px-1">广播电视、流媒体传输、录制</td>
                        <td class="t-light-gray">
                            <ul>
                                <li>最初为数字电视广播设计（DVB、ATSC）</li>
                                <li>结构基于固定大小的包，减少丢包造成的播放问题</li>
                                <li>原生支持边录边播（同时直播和录制）</li>
                                <li>比 MP4/MKV 冗余多，文件体积稍大，元数据支持较弱</li>
                                <li>几乎所有播放器和硬件解码器都支持</li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>

            <h3>视频编码专利</h3>
            <p>常见的有核心技术专利（特定编码步骤、装置设备具体实现等应用）、标准必要专利（即构成 AVC、HEVC、AV1 等编码所需的专利）、免费开放许可等。由于涉及视频编码的专利/权利人多，因此一种视频编码是由多项专利打包的专利池所构成，由专利池管理公司运营。</p>
            <p>HEVC 的专利许可最初混乱且昂贵，与 AVC 的许可方式截然不同。实际上这个问题显著阻碍了 HEVC 的推广，主要的专利池包括：</p>
            <ul>
                <li>HEVC Advance：包含三星、高通、GE、杜比等公司的专利</li>
                <li>MPEG LA：包含来自三菱、日本广播协会NHK、JVC Kenwood、苹果等公司的专利</li>
                <li>Velos Media：包含来自爱立信、松下、索尼等公司的专利</li>
            </ul>
            <div class="align-items-center">
                <img src="files/basics/Pay-For-HEVC-Windows.webp" alt="Pay-For-HEVC-Windows" class="img-medium">
                <p class="text-gray-side mt-0">图：Windows 文件管理器预览 HEVC 编码视频、HEIF 图像的组件，定价 $0.99 USD。通过让用户支付这比费用，微软以“产品默认不包含”而绕过了 HEVC 的专利费。</p>
            </div>

            <h3>数据大小单位</h3>
            <ul class="overflow-auto">
                <li><b>bit（比特）</b>：最小的计量单位，<span class="text-blue-math">\(1 \text{bit} = \frac{1}{8} \text{Byte}\)</span>，衡量传输流量</li>
                <li><b>Byte（字节）</b>：<span class="text-blue-math">\(8 \text{bit} = 1 \text{Byte}\)</span>，衡量文件大小</li>
            </ul>
            <h4>二进制千进位（准确）</h4>
            <ul class="overflow-auto">
                <li><b>kibi-bit（Kb，千比特）</b>：1024 比特，2<sup>10</sup></li>
                <li><b>kibi-Byte（KB，千字节）</b>：1024 字节，2<sup>10</sup></li>
                <li><b>mebi-bit（Mb，兆比特）</b>：1024<sup>2</sup> = 1048576 比特</li>
                <li><b>mebi-Byte（MB，兆字节）</b>：1024<sup>2</sup> = 1048576 字节</li>
                <li><b>gibi-bit（Gb，吉比特）</b>：1024<sup>3</sup> = 1073741824 比特</li>
                <li><b>gibi-Byte（GB，吉字节）</b>：1024<sup>3</sup> = 1073741824 字节</li>
            </ul>
            <h4>十进制千进位（模糊）</h4>
            <ul class="overflow-auto">
                <li><b>kilo-bit（Kb，Kib，千比特）</b>：1000 比特</li>
                <li><b>kilo-Byte（KB，KiB，千字节）</b>：1000 字节</li>
                <li><b>mega-bit（Mb，Mib，兆比特）</b>：1000<sup>2</sup> 比特</li>
                <li><b>mega-Byte（MB，MiB，兆字节）</b>：1000<sup>2</sup> 字节</li>
                <li><b>giga-bit（Gb，Gib，吉比特）</b>：1000<sup>3</sup> 比特</li>
                <li><b>giga-Byte（GB，GiB，吉字节）</b>：1000<sup>3</sup> 字节</li>
            </ul>
            <div class="align-items-center">
                <img src="files/basics/Data-Sizes.png" alt="Data-Sizes" class="img-medium">
                <p class="text-gray-side mt-0">图：比特，字节与体积时间比的转换</p>
            </div>
            <p>操作系统（处理器、内存）的“字节”是以二进制换算的，而储存容量（闪存、硬盘）的“字节”是十进制换算的。一开始储存容量不大，而 1000 进和 1024 进差 2.4%，不如多卖电脑重要，就有了现在不统一的容量称呼</p>
            <ul class="text-gray-side">
                <li>使用十进制表示数据和容量大小除了不准确外，还是会比二进制方便很多</li>
                <li>Mac OS X 10.6 开始整个系统都以十进制表示大小</li>
                <li>为了兼容，Windows 系统的单位可能永远都不会改</li>
            </ul>

            <h3>码率/比特率 Bitrate</h3>
            <p>文件体积每秒，单位 <span class="text-blue-emph">bps，Bps，Kbps，KBps，Mbps，MBps，Gbps，GBps</span> 等。“ps”即 per second，也可写作“Kb/s，Mb/s”等。</p>
            <ul>
                <li>长 1 分钟，10MB 大小的视频文件的平均码率为<span class="text-blue-math">\( (10 \div 1 \times 60) \times 8 \text{bit} = 1333.3 \text{Kbps} \)</span></li>
                <li>同样 10MB 的视频下载 1 分钟，平均下来网速即<span class="text-blue-math">\( \frac{10}{1 \times 60}=166.67 \text{KBps} \)</span>，<span class="text-blue-math">\( 166.67\times 8 \text{bit} = 1333.33 \text{Kbps} \)</span>
                    <ul class="text-gray-side">
                        <li>这里的 ÷1 代表缩放到一分钟范围，×60 代表缩放到一秒，×8bit 代表 1 Byte 转 8 bit。</li>
                    </ul>
                </li>
            </ul>

            <h3>存储技术带宽 Storage Bandwidth</h3>
            <p>视频是连续大文件写入，几乎不存在随机读写性能需求。因此写入视频的速度可以直接按照硬盘的连续写入带宽/速度看待：</p>
            <ul>
                <li><b>PCIe 4.0x4 SSD</b>：约 63Gbps（8GBps）</li>
                <li><b>PCIe 3.0x4 SSD</b>：约 31Gbps（4GBps），同时也是 PCIE 4.0x2 SSD 带宽</li>
                <li><b>3840x2160x120 未压缩 RGB 3×8bit 视频流（120 fps）</b>：约 24Gbps</li>
                <li><b>3840x2160x90 未压缩 RGB 3×8bit 视频流（90 fps）</b>：约 18Gbps</li>
                <li><b>3840x2160x120 无损压缩 YUV 8bit 视频流（估计）</b>：
                    <ul>
                        <li><b>4:2:0</b>：约 7.2 Gbps</li>
                        <li><b>4:2:2</b>：约 9.6 Gbps</li>
                        <li><b>4:4:4</b>：约 14.4 Gbps</li>
                    </ul>
                </li>
                <li><b>SATA3 SSD</b>：有效带宽约 4.8Gbps</li>
            </ul>
            <p>当然，24Gbps 的写入量太过夸张，只要 300 多秒就会写满 8000Gb（1TB）的空间，这个大小也注定与网络传输无缘了。</p>
            <p class="text-gray-side">注：固态硬盘实则数据详见 <a href="https://www.tomshardware.com/features/ssd-benchmarks-hierarchy">TomsHardware</a>。</p>

            <h3>色彩</h3>
            <p>人眼感光细胞捕获特定强度的电磁波（可见光），然后通过大脑处理，产生了我们所看到的幻觉。实际上，色彩只有一个标量属性，即频率。</p>
            <div class="align-items-center">
                <img src="files/basics/Color-Spectrum.png" alt="Color-Spectrum1" class="img-medium">
                <p class="text-gray-side mt-0">图：色彩的波形频率变化，见<a href="https://en.wikipedia.org/wiki/Electromagnetic_spectrum">维基百科</a>。</p>
            </div>

            <h3>亮度</h3>
            <ul class="overflow-auto">
                <li><b>物理亮度</b>：可见光电磁波的强度或振幅，以流明 lumen/lm，坎德拉/烛光量 candela/cd，或尼特 nits/cdm<sup>2</sup> 计量：
                    <ul class="text-gray-side">
                        <li>1cd/lm 大约为一支普通蜡烛的亮度。</li>
                        <li>由于是强度，一般来说，灯泡电压越高、火药能量密度越高，发光就越明亮
                            <ul>
                                <li>因此定义：能量和光强/光压的相关性呈正比</li>
                            </ul>
                        </li>
                        <li>Nits 代表 1cd 光源投射到一平方米（一般情况下距离一米）区域后所剩的亮度，主要用于显示器的亮度设定。一般来说，<span class="text-blue-math">1 nit ≈ 3.426 lm</span>，但实际的换算关系取决于光源和测量仪器的不同与误差。</li>
                    </ul>
                </li>
                <li><b>软硬件亮度</b>：代表灰度像素值的大小，值越大表示像素点越亮，但最大亮度受硬件和用户设定限制。伽马 gamma/Y 值定义了像素的亮度范围，最小值 0 为黑色：
                    <ul class="text-gray-side">
                        <li>位深 4bit 下，最大值/纯白为 15（<code>0xF</code>）</li>
                        <li>位深 8bit 下，最大值/纯白色为 255（<code>0xFF</code>）</li>
                        <li>位深 10bit 下，最大值/纯白色为 1023（<code>0x3FF</code>）</li>
                    </ul>
                </li>
            </ul>
            <p>YUV / YCbCr 色彩空间图像的亮度平面 Y，或者 RGB 图像分离出的亮度/灰度平面，有时也被称为伽马平面或 Y 平面。</p>
            
            <h3>灰度/灰阶 Grayscale</h3>
            <p>代表将色彩信息去除，只保留黑、灰、白色的单通道图像。</p>

            <h3>硬件色深 Depth 与范围 Range</h3>
            <p>对应电压的缩放值。由显示器的驱动板/主控板接收 GPU 输出的数字信号，并转义为像素点的电压得到。因此使用了 CRT 显像管的电视可能是模拟电视，也可能是数字电视，取决于有没有如 HDMI，DisplayPort 等数字信号接口。</p>

            <h4>有限色深（Limited/Analog/TV）</h4>
            <p>模拟电视使用了 <span class="text-blue-math">\( 0 \text{mV ~ } 700 \text{mV} \)</span> 的输入电压表示色深，对应软件的完整色深。但早期的模拟电视缺乏电压限制功能——倘若电视台的信号调制器（类似于家庭网络的猫、Modem）出现偏差或干扰，就可能有大量用户的电视出现烧屏现象。所以显示标准上要求信号层面限制电压范围，牺牲一些色深来解决问题，得到了有限范围。</p>
            <p>到了数字时代，电视厂商都使用 HDMI 协议的显示信号接口，电脑厂商则使用 DisplayPort 的显示信号接口，所以在“电脑接电视”，和“游戏主机接显示器”时往往需要额外的输入和输出设置，才能得到明暗过渡正常的画面。</p>
            <ul class="text-gray-side overflow-auto">
                <li>一般在显示器的 OSD 设置界面上看到，写作兼容/有限/模拟/电视范围 </li>
                <li>一般来说，数字显示器/数字电视应该是原生支持设置为输入完整色深的，若没有则可以通过设置 HDMI Black Level 来缩放到正常明暗过渡</li>
            </ul>

            <h3>软件的色深 Depth 与范围 Range</h3>
            <p>数字色深的分阶用位/bit 表示。如四位 4bit 16 深 <span class="text-blue-math">\( 2^4 \)</span>、八位 8bit 256 深 <span class="text-blue-math">\( 2^8 \)</span>、10bit 1024 深 <span class="text-blue-math">\( 2^{10} \)</span> 的形式表示。</p>
            <div class="align-items-center">
                <img src="files/basics/Full-and-Limited-Range.png" alt="Full-and-Limited-Range" class="img-medium">
                <p class="text-gray-side mt-0">图：完整色深 Fullrange 与有限/TV 色深 Limited，包括上述说明的更优版本见<a href="https://www.youtube.com/watch?v=8sAJWtgQ2t8">硬件茶谈</a>。</p>
            </div>

            <h4>完整色深兼容有限色深</h4>
            <button type="button" class="collapsible border-main rounded-3">点击展开/折叠内容</button>
            <div class="coll-content">
                <ul class="text-smaller overflow-auto">
                    <li>8 位色深下，从完整 0~255 缩减至 16~235 的有限区间（256 深）</li>
                    <li>10 位色深下，从完整 0~1024 缩减至 64~940 的有限区间（876 深）</li>
                    <li>因为有限范围视频占据绝大多数，所以播放器默认读取有限范围，通过 Y/C 转换算出完整色深</li>
                    <li>图像格式有色深的概念，但不存在“有限范围”的概念</li>
                    <button type="button" class="collapsible border-main rounded-3">点击展开/折叠内容：密度与范围的用语说明</button>
                    <div class="coll-content">
                        <li>色深密度代表色深大小所指的黑~白区间密度，而“有限区间/范围”代表“密度里的有效范围”</li>
                        <li>严格地说，不存在“色深范围”，因为范围自始至终是黑到白，只有有限范围才能修改范围</li>
                    </div>
                </ul>

                <h4>软件层完整范围 Full/PC</h4>
                <ul class="text-smaller overflow-auto">
                    <li>8 位密度下，色彩范围从 0 到 255 的完整 256 色深，密度较高</li>
                    <li>10 位密度下，色彩范围从 0 到 1023 的完整 1024 色深，密度很高</li>
                    <li>实际情况下，色深的视频剪辑软件选项应该设置为“保持和原素材一致”。因为：
                        <ul>
                            <li>有的设备和软硬件默认导出有限范围，但录制的时候忘了改</li>
                            <li>有的素材会误标记范围为有限</li>
                            <li>有限和完整范围的转换可能会产生色带 Banding 失真</li>
                        </ul>
                    </li>
                </ul>
            </div>

            <h4>色深转换的错误</h4>
            <button type="button" class="collapsible border-main rounded-3">点击展开/折叠内容</button>
            <div class="coll-content">
                <p>输出设置为有限，未经 Y/C 转换，连接到设置为输入完整范围的显示器，显示器缺失最暗和最亮的范围，呈现灰蒙蒙的画面，例如：</p>
                <ul class="text-smaller overflow-auto">
                    <li>PC 用 HDMI 连接显示器所致，需纠正显卡输出设置</li>
                    <li>显示器设置的对比度远高于亮度，需纠正显示器设置</li>
                </ul>

                <p>输出设置为完整，未经 Y/C 转换，连接到设置为输入有限区间的显示器，显示器忽略 8bit 下 0~15 和 235~255 的亮度范围，出现画面过亮过暗（饱和度过高）的画面，例如：</p>
                <ul class="text-smaller overflow-auto">
                    <li>古老 / 低成本的 HDMI 电视只支持有限范围，PC/Xbox/PlayStation 设置为输出完整所致</li>
                </ul>

                <p>yuvj 色彩空间中的 j 被误解，而使用了无效或错误的转换处理导致</p>
                <ul class="text-smaller overflow-auto">
                    <li>j 代表 jpeg，是 ffmpeg 现已淘汰的定义，但 ffprobe 中可能还会遇到</li>
                    <li>ffmpeg 的 color_range 参数说明中可以看到 jpeg 和完整色域都是参数值 2</li>
                </ul>

                <p>heic 格式的图片被错误转换到 jpeg 或错误显示导致，一般出现在手机上，以及 Windows 11 的图片浏览器中</p>
                <p>HDR 视频在设备没有正确配置的情况下直接显示导致</p>
            </div>

            <h3>伽马曲线/伽马映射</h3>
            <ul class="text-smaller overflow-auto">
                <li><b>生理伽马映射</b>：人眼对于亮度的感知与物理亮度的线性变化所异
                    <ul class="text-gray-side">
                        <li>人眼敏感于低至中等亮度的变化，而对中高亮度的变化则相对不太敏感。因此，当内容的亮度变化呈直线关系时，人们会感觉到“发白”</li>
                        <li>许多游戏的初始设置中，“将滑块调节到能清晰看到左侧暗部图像”实际上就是在调节伽马曲线，而且是生理伽马曲线</li>
                        <li>相机 CMOS 捕获的线性亮度（RAW 直出格式）在人眼看来会显得过亮“发白”，需要进行“黑化”校正</li>
                    </ul>
                </li>
                <li><b>软硬件伽马映射</b>：屏幕电压与线性亮度变化之间的关系并非线性
                    <ul class="text-gray-side">
                        <li>CRT 显示屏一般需要放大电压到 <span class="text-blue-math">\( v^{2.2} \)</span> 才能够直线地显示亮度变化</li>
                        <li>sRGB 标准则因为 CRT 显示器的特性相当于已经对图像进行了“黑化”处理，因此在录制过程中就会将图像进行“白化”处理：<span class="text-blue-math">\( \gamma^{\frac{1}{2.2}} \)</span></li>
                        <li>若编辑 RAW 直出图像的软件未打开 Adobe 软件默认关闭的“按伽马系数混合 RGB 颜色，伽马值为 1”的设定，图层透明通道之间的过渡会显得杂乱不堪。</li>
                    </ul>
                </li>
            </ul>
            <div class="align-items-center">
                <img src="files/basics/Y-Gamma.webp" alt="Subsampling" class="img-medium">
                <p class="text-gray-side mt-0">图：对亮度平面调整伽马映射，来源：<a href="https://developer.apple.com/documentation/accelerate/adjusting-saturation-and-applying-tone-mapping">developer.apple.com</a>。</p>
            </div>

            <h3>伽马矫正</h3>
            <p><b>两种方式</b>：向上提亮缩放“白化” <span class="text-blue-math">\( s = cr^\frac{1}{\gamma} \)</span> 和向下变暗缩放“黑化” <span class="text-blue-math">\( s = cr^\gamma \)</span>。</p>
            <div class="align-items-center">
                <img src="files/basics/Gamma-Correction.png" alt="Gamma-Correction" class="img-medium">
                <p class="text-gray-side mt-0">图：伽马矫正的指数算式，此处<span class="text-blue-math">c = 1</span>代表 0~1 的亮度区间，8bit 256 深则<span class="text-blue-math">c = 256</span>，见<a href="https://www.desmos.com/calculator/shseuk9jcb?lang=zh-CN">desmos 互动例</a>。</p>
            </div>
            
            <h3>对比度 Contrast</h3>
            <p>任意量纲的间距。在图像与显示器中代表最亮~最暗的亮度差，音频中代表“动态范围”，对比度低的图像会“发灰”，因为当前的亮度设置位于这个灰度水平上；对比度高的图像会显得生动，因为显示出来的色彩往往更符合心理预期。</p>
            <div class="align-items-center">
                <img src="files/basics/Contrast.webp" alt="Contrast" class="img-medium">
                <p class="text-gray-side mt-0">图：对比度。</p>
            </div>
            <h4>对比过大的问题</h4>
            <p>在安静环境下听音乐时，有的音频段落会太响、画面亮度太刺眼；而有的场景下有小到听不清、或画面暗的看不清细节。</p>
            <h4>调节对比度</h4>
            <p>在 DVD、蓝光播放机上，用户可以方便地通过遥控器调整；电脑麻烦些，需要通过调节显示器的 OSD 菜单，或下载第三方插件，或在播放器软件中按快捷键调节；智能手机可以通过显示色彩模式和第三方软件调节，但罕有播放器支持对比度调节，因此体验最差。</p>

            <h3>饱和度 Saturation</h3>
            <p>一般指液体在特定压力和温度下溶解了某种成分的程度，达到最高时会沉积而不再溶解。图像中则代表颜色接近 100% 纯色的程度或“彩度”，饱和度越高则图像越鲜艳，为零时得到灰阶图像；最大时得到纯色图像。对比度接近饱和度，但不是饱和度。</p>
            <div class="align-items-center">
                <img src="files/basics/Saturation.webp" alt="Saturation" class="img-medium">
                <p class="text-gray-side mt-0">图：饱和度，来源：<a href="https://developer.apple.com/documentation/accelerate/adjusting-saturation-and-applying-tone-mapping">developer.apple.com</a>。</p>
            </div>

            <h3>像素 Pixel / pix / pel / px</h3>
            <p>像素是组成图像的最小单位，决定了图像的物理大小和分辨率。一般情况下分为屏幕的硬件像素大小，和图片/视频的软件像素大小两种。当软件像素小于硬件像素时，显示 100% 大小的图片会变小，或者通过缩放滤镜将图片放大以适应屏幕。反之，若硬件像素大小小于软件像素，则会使用缩放滤镜将图片缩小至合适的尺寸，或者图片会溢出屏幕。图像中的每个像素都有位置和颜色两份信息。</p>

            <h3>每英寸像素 Pixel Per Inch / PPI</h3>
            <p>指屏幕或印刷设备上的物理像素密度，这取决于设计时预期的观看距离。屏幕的 PPI 高则适合近距离观看，因为物理像素更密集。在印刷设备的 PPI 越高，打印出的图像就越细腻。软件的 PPI 主要用于计算新建图像的像素大小和分辨率，以确保图像有着适当的大小和清晰度。</p>
            <ul class="text-gray-side overflow-auto">
                <li>矢量图形通常不涉及 PPI 概念，因为它们以数学方式描述图像，可以无限放大而不失真</li>
                <li>高 PPI 的显示器是一种较新的规格，旧的软件在这些显示器上会出现模糊，或界面过小的问题，见<a href="https://www.youtube.com/watch?v=jfAH4Ym5D6Q">硬件茶谈</a></li>
            </ul>
            <!--<h3>位图 Bitmap 与矢量图 Vector</h3>
            <p>位图使用像素和元数据（例如 n 个像素后换行）来表示图像。每个像素都包含特定的颜色信息，通常表示为 RGB 或 YCbCr 值。用于描述照片和复杂图像，但当放大时会失真，因为像素的信息已经固定，而放大只是用滤镜在其中插值填空的结果。</p>
            <p>矢量图使用图形函数与代码来描述图像（如 JavaFX，SVG）。它们以函数定义图像的形状、线条和颜色。放大矢量图不会失真，且可以在不同的尺寸和分辨率下保持清晰度：
                <svg xmlns="http://www.w3.org/2000/svg" role="img" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="1em" width="1em">
                    <title>GitHub</title>
                    <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
                </svg>
                <img src="./files/svg-examples/filetype-sql.svg" alt="sql"/>
                <img src="./files/svg-examples/pin-map.svg" alt="pinned-map"/>
                <img src="./files/svg-examples/mailbox.svg" alt="mailbox"/>
                <img src="./files/svg-examples/hdd-network.svg" alt="network-hdd"/>
                <img src="./files/svg-examples/menu-button-wide.svg" alt="menu-button"/>
                <img src="./files/svg-examples/card-list.svg" alt="card-list"/>
                <img src="./files/svg-examples/ethernet.svg" alt="ethernet"/>
                <img src="./files/svg-examples/bricks.svg" alt="bricks"/>
                <img src="./files/svg-examples/postcard-heart.svg" alt="postcard-heart"/>
                <img src="./files/svg-examples/opened-email-envelope_modified.svg" alt="email"/>
                <img src="./files/svg-examples/person-video2.svg" alt="person-video"/>
                <img src="./files/svg-examples/person-workspace.svg" alt="person-workspace"/>
                <img src="./files/svg-examples/obs_94846.svg" alt="obs"/>
                <img src="./files/svg-examples/bullseye.svg" alt="bullseye"/>
                <img src="./files/svg-examples/clock.svg" alt="clock"/>
                <img src="./files/svg-examples/globe2.svg" alt="globe"/>
                <img src="./files/svg-examples/database.svg" alt="database"/>
                <img src="./files/svg-examples/math-svgrepo-com.svg" alt="math-symbols"/>
                <img src="./files/svg-examples/file-earmark-music-fill.svg" alt="music"/>
                <img src="./files/svg-examples/cup-hot-fill.svg" alt="cup-hot-fill"/>
                <img src="./files/svg-examples/ffmpeg_icon_132402.svg" alt="ffmpeg"/>
                <img src="./files/svg-examples/javascript_logo_icon_145155.svg" alt="Javascript"/>
                <img src="./files/svg-examples/c-sharp.svg" alt="c-sharp"/>
                <img src="./files/svg-examples/filetype-sql.svg" alt="sql"/>
                <img src="./files/svg-examples/php-logo.svg" alt="php"/>
                <img src="./files/svg-examples/cloud-arrow-up.svg" alt="cloud-upload"/>
                <img src="./files/svg-examples/markdown.svg" alt="markdown"/>
                <img src="./files/svg-examples/photoshop_icon_130268.svg" alt="photoshop"/>
                <img src="./files/svg-examples/adobe-audition-cc-creative-cloud_78302.svg" alt="audition"/>
                <img src="./files/svg-examples/adobe-after-effects-cc-creative-cloud.svg" alt="after-effects"/>
                <img src="./files/svg-examples/adobe-premiere-pro-cc-creative-cloud_78301.svg" alt="premiere"/>
            </p>
            <ul class="text-gray-side overflow-auto">
                <li>因为渲染算力不够，所以以前的矢量图格式难以被推广</li>
                <li>因为要保证参差不齐的“矢量图代码质量”在不同渲染器下画面一致；所以现在的矢量图格式仍然难以推广
                    <ul><li>使以上这些 SVG 的大小一致... 需要手动改写代码</li></ul>
                </li>
                <li>在 Wordpress（个人博客网站软件）中使用 SVG 图形仍然需要第三方插件才能实现部分支持</li>
                <li>当然，“文本”也可以被视为一种矢量图，这样则位图反而更少见了</li>
            </ul>-->
            <h3>色彩空间 Color Space</h3>
            <div class="row">
                <p id="LR-UD-001" class="col-10">用于表示和处理图像颜色的数据格式，具有适用于各种不同应用场景的多种类型。最常用的是分为硬件和操作系统的 RGB 色彩空间，以及内容的 YUV/YCbCr 色彩空间。见 <a href="https://www.youtube.com/watch?v=FTKP0Y9MVus">Captain Disillusion</a> 的科普。</p>
                <img src="files/basics/RGB-to-YCbCr-to-RGB.png" alt="RGB-to-YCbCr-to-RGB" id="LR-UD-002" class="img-small img-right col-2 mb-auto">
            </div>
            <p>RGB 色彩空间由红色 Red、绿色 Green、蓝色 Blue 三个通道组成，每个通道的数值表示相应颜色的强度，对应着显示器红色 LED，绿色 LED 和蓝色 LED。常用于显示器、摄像头和图形处理等硬件和软件系统中。</p>
            <p>YUV/YCbCr 色彩空间是另一种常见的色彩表示方式，用于存储和传输视频数据。Y 代表亮度 Luminance，而 U、V 代表色度 Chrominance。YCbCr 特指数字信号，YUV 特指模拟信号，再无区别。由于后者字数更少且不需要频繁切换大小写，打字更容易，所以 YUV 拼写后来逐渐被当做讨论用的“平替”。</p>
            <table class="table-center">
                <thead>
                    <tr>
                        <th>🎆色彩格式</th>
                        <th>构成色</th>
                        <th>特点</th>
                        <th>存在原因</th>
                        <th>支持范围</th>
                    </tr>
                </thead>
                <tbody>
                    <tr class="border-bottom">
                        <td class="px-1"><span style="color:red">R</span><span style="color:lime">G</span><span style="color:blue">B</span></td>
                        <td class="px-1">红绿蓝</td>
                        <td class="px-1">通用</td>
                        <td class="px-1">使显示器/照相机通用</td>
                        <td class="px-1">几乎所有可视媒体</td>
                    </tr>
                    <tr class="border-bottom">
                        <td class="px-1"><span style="color:#BFBFBF">A</span><span style="color:red">R</span><span
                                style="color:lime">G</span><span style="color:blue">B</span></td>
                        <td class="px-1">α 红绿蓝</td>
                        <td class="px-1">透明通道</td>
                        <td class="px-1">便于图层化编辑</td>
                        <td class="px-1">图片，部分视频</td>
                    </tr>
                    <tr class="border-bottom">
                        <td class="px-1"><span style="color:aqua">C</span><span style="color:fuchsia">M</span><span
                                style="color:yellow">Y</span><span style="color:black">K</span></td>
                        <td class="px-1">湛 zhàn 洋黄黑</td>
                        <td class="px-1">减法色彩</td>
                        <td class="px-1">卖墨盒</td>
                        <td class="px-1">打印纸</td>
                    </tr>
                    <tr>
                        <td class="tx-1"><span style="background-image: linear-gradient(190deg, rgb(68, 68, 68), white);background-clip: text; -webkit-text-fill-color: transparent;">Y</span><span style="background-image: linear-gradient(72deg, #80AB00, #8054FF); background-clip: text; -webkit-text-fill-color: transparent;">Cb</span><span style="background-image: linear-gradient(72deg, #00DB80, #FF2480); background-clip: text; -webkit-text-fill-color: transparent;">Cr</span>/YUV，YPbPr</td>
                        <td class="px-1">白蓝 - 黄红 - 绿</td>
                        <td class="px-1">压缩</td>
                        <td class="px-1">压缩视频图片</td>
                        <td class="px-1">所有有损压缩</td>
                    </tr>
                </tbody>
            </table>

            <h3>色度采样 Chroma Subsampling</h3>
            <p>YUV/YCbCr 色彩空间下，利用人眼对色度细节不敏感的特性（见下图全分辨率和半分辨率的色度面），降低色度平面的分辨率，从而压缩图像。色度采样格式通常用三个数字表示，例如 4:4:4、4:2:2 等。编码时下采样，解码时上采样。</p>
            <div class="align-items-center">
                <img src="files/basics/Subsampling.png" alt="Subsampling" class="img-medium">
                <p class="text-gray-side mt-0">图：色度采样，来源：<a href="https://developer.apple.com/documentation/accelerate/adjusting-saturation-and-applying-tone-mapping">developer.apple.com</a>。</p>
            </div>

            <p>A:B:C 代表微观分辨率下，每个长 A 像素，高 2 像素的空间，第一行缩到 B 个色度像素，第二行缩到 C 个色度像素。如 4:2:2 代表色度平面的每个 4x2 微观区间中，第一行的色度分量保留 2 个像素，第二行的色度分量也保留 2 个像素。色度采样详见下表：</p>
            <div class="overflow-auto">
                <table class="table-center align-items-center text-smaller" style="white-space: nowrap;">
                    <thead class="thead-no-border">
                        <tr class="t-invert-dark">
                            <th class="px-0">👾采样</th>
                            <th class="px-0">1920x1080 下宏观</th>
                            <th class="px-0" colspan="4">色度 4x2 微观</th>
                            <th class="px-0">特点</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr class="border-bottom">
                            <td class="t-light-gray" rowspan="2">4:4:4</td>
                            <td rowspan="2">亮度，色度皆 100% 宽 100% 高（色度 1920x1080）</td>
                            <td class="px-0 t-light-gray square" style="white-space: nowrap;">色素</td>
                            <td class="px-0 t-invert-light square" style="white-space: nowrap;">色素</td>
                            <td class="px-0 t-light-gray square" style="white-space: nowrap;">色素</td>
                            <td class="px-0 t-invert-light square" style="white-space: nowrap;">色素</td>
                            <td class="px-0" rowspan="2" style="white-space: wrap;">
                                视频滤镜可直接作用于亮度或色度平面，<br>
                                而 RGB 色彩空间需要转过去、应用滤镜、再转换回来，<br>
                                因此非常适合图像和视频编辑，并且便于压缩色度平面
                            </td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-0 t-invert-dark" style="white-space: nowrap;">色素</td>
                            <td class="px-0 text-lightgray" style="white-space: nowrap;">色素</td>
                            <td class="px-0 t-invert-dark" style="white-space: nowrap;">色素</td>
                            <td class="px-0 text-lightgray" style="white-space: nowrap;">色素</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="t-light-gray" rowspan="2">4:2:2</td>
                            <td rowspan="2">亮度 100% 宽 100% 高，色度 50% 宽 100% 高（色度 960x1080）</td>
                            <td class="px-0 t-light-gray twoByOne" colspan="2">色素 ←</td>
                            <td class="px-0 t-invert-light twoByOne" colspan="2">色素 ←</td>
                            <td class="px-0 t-light-gray" rowspan="4" style="white-space: wrap;">
                                逐行扫描，色度像素靠插值放大补全。<br>
                                由于人眼对色度变化不敏感，同时使用整数倍的缩小放大，<br>
                                因此在提高压缩的同时除了边缘细节对齐误差外的损失可以忽略不计
                            </td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-0 t-invert-dark twoByOne" colspan="2" style="white-space: nowrap;">色素 ←</td>
                            <td class="px-0 text-lightgray twoByOne" colspan="2" style="white-space: nowrap;">色素 ←</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="t-light-gray">4:2:0</td>
                            <td>亮度 100% 宽 100% 高，色度 50% 宽 50% 高 960x540</td>
                            <td class="px-0 t-light-gray square" colspan="2">色素 ←<br>↑&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⬉</td>
                            <td class="px-0 t-invert-light square" colspan="2">色素 ←<br>↑&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⬉</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="t-light-gray">4:0:0</td>
                            <td>亮度 100% 宽 100% 高的灰度视频，或丢弃色度信息的图像/视频</td>
                            <td class="px-0" colspan="4" style="white-space: nowrap;"></td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="t-light-gray" rowspan="2">4:1:1</td>
                            <td rowspan="2">亮度 100% 宽 100% 高，色度 25% 宽 100% 高 480x1080</td>
                            <td class="px-0 t-light-gray fourByOne" colspan="4" style="white-space: nowrap;">色素 ← ← ← ←</td>
                            <td rowspan="4" style="white-space: wrap;">交错扫描 Interlaced，横着扫描可以避免将上场、下场的像素混淆</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-0 t-invert-dark fourByOne" colspan="4" style="white-space: nowrap;">色素 ← ← ← ←</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="t-invert-light" rowspan="2">4:1:1-par4:3</td>
                            <td rowspan="2">亮度 75% 宽 100% 高，1440x1080 色度 18.75% 宽 100% 高，360x1080</td>
                            <td class="px-0 t-light-gray fourByOne" colspan="4" style="white-space: nowrap;">色度像素 ←×5.333</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-0 t-invert-dark fourByOne" colspan="4" style="white-space: nowrap;">色度像素 ←×5.333</td>
                        </tr>
                        <tr>
                            <td class="t-invert-light">4:2:0-par4:3</td>
                            <td>亮度 75% 宽 100% 高，1440x1080 色度 37.5% 宽 50% 高，720x540</td>
                            <td class="px-0 t-light-gray square" colspan="2" style="white-space: nowrap;">2.667 ←<br>↑ 2.848 ⬉</td>
                            <td class="px-0 t-invert-light square" colspan="2" style="white-space: nowrap;">2.667 ←<br>↑ 2.848 ⬉</td>
                            <td class="px-0 t-light-gray" style="white-space: wrap;">逐行扫描，非方形亮度像素，除了清晰度更低，色度像素在拉伸后也会出现更大的对齐偏差，曾被用于电视台和视频网站（有的横向有的纵向）压缩视频，现在基本已经绝迹</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="align-items-center mt-3">
                <img src="files/basics/Color-Space-Handling.jpg" alt="Color-Space-Handling" class="img-medium">
                <p class="text-gray-side mt-0">图：RGB 与 YCbCr 的转换，色度采样的使用及编解码与录制、传输和显示的关系</p>
            </div>

            <h3>视频帧 Video Frame</h3>
            <p>描述连续图片序列中的单张图片（随便拍一张图片不算，连拍算）。有帧大小、帧率/帧数、帧类型（关键帧，过渡帧）等描述规格，构成了图像内容运动的假象。</p>

            <h3>帧率 Frame Rate / Frames per second / FPS</h3>
            <p>每秒刷新的图像帧数，越高则变化越流畅。不同的内容类型会根据视频标准，成本和艺术效果来选择一个合适的帧率来拍摄和制作。</p>

            <h3>画面流畅度 Video fluidity</h3>
            <p>在智能手机产品的发展阶段，有个叫一加的品牌率先推出了 90 Hz 屏幕的手机，这使得系统流畅度，以及用户体验被显著提升，该手机也成为了当年的热门产品；而与此同时，电影、电视剧的 24 fps 是流畅的、浏览器观看网页的 60 fps 是流畅的、漫画材质动画的 23.976（24 fps 丢帧）同样是流畅的，唯独第一人称射击的电子竞技（e-Sport FPS）游戏选手和同类游戏玩家纷纷放弃了更高分辨率的显示器，而是专门选购了 120 Hz 或更高的显示器，将游戏画质设置到最低，只为降低延迟。</p>
            <p>随着帧间插值渲染（Frame Interpolation）所依赖的 GPU 效率变得足够快，便有许多人尝试对电影和漫画材质动画插帧，从而使画面流畅，然而结果不是充斥伪运动感的飘忽画面，就是因画面前后部分范围突变而产生了采样错误；与此同时，使用 Live2D 动补技术创建的虚拟形象却让漫画材质动画的人物图层在 60 fps 帧率下活灵活现的显示。这种属于 3D 材质动画的流畅在每一名使用 Live2D 以及其相关技术的主播上都能轻松实现，却是插帧滤镜用户无法跨越的技术鸿沟。</p>
            <p>实际上，流畅度的核心在于移动画面的保真，符合这个条件的画面类型有背景平移（Panning），充斥智能手机的全屏动画，FPS 游戏的发现到杀敌用时（TTK）等“帧率不够就会丢失动态信息”的情况。因此，每一帧画面只有在正确的时间显示正确的时长，才能对流畅度有所贡献。</p>
            <p>录像电影和漫画材质动画有着内容生产和储存的成本与时限，自然不会随意地提高帧率。但低帧率有低帧率的办法——电影会限制镜头平移速度（即电影运镜）、对快速移动的物件添加动态模糊（摄影快门角度和速度）；漫画材质动画会利用视觉暂留效应的一拍 N 作画，也会使用室内等移动物件少的场景，这才在更低的帧率下实现了对人眼来说足够流畅的画面，这种“已流畅”的画面自然是无法通过简单的插帧来提高流畅度的。</p>
            <p>随着手机剪辑网络视频的流行，更多的“纯文本”视频开始涌现到视频网站。这些视频往往就算只有 1 fps（1 帧每秒）、0.2 fps（5 秒每帧）也会是无比流畅的。</p>

            <h4>恒定帧率、可变帧率 Constant / Variable frame rate</h4>
            <p>恒定帧率的视频播放和剪辑都最具兼容性。可变帧率技术有助于解决手机录像时的发热和耗电速度快的问题，但也有着剪辑软件兼容性的问题（每个用到的滤镜都必须支持可变帧率）。因此，录制视频时应根据设备的电量和散热能力进行选择，而录制需要剪辑的素材时则应选择恒定帧率。</p>
            
            <button type="button" class="collapsible border-main rounded-3">点击展开/折叠内容：ffmpeg 转换到恒定帧率的命令</button>
            <div class="coll-content">
                <code>ffmpeg -i &lt;输入&gt; -vsync cfr -y -vf fps=60 -c:a copy -f yuv4mpegpipe - | x264 &lt;参数&gt; - --demuxer y4m --output &lt;输出.mp4&gt;</code>
                <ul class="text-gray-side">
                    <li>于视频元数据里也有着标错的情况，所以用 MediaInfo 等工具查看到视频帧率是 Variable 时，还要用播放器逐帧查看，或者用 ffprobe 检测。见 <a href="https://nazorip.site/archives/169/">ffprobe 教程</a></li>
                </ul>
            </div>

            <h4>小数帧率 / 丢帧、剪辑素材对齐问题</h4>
            <p>NTSC 模拟电视每个频道的标准带宽大约为 6MHz（但实际宽度仅为 4.5MHz）。接下来发生的事谁都没有预料到——彩色电视出现了。结果是原本的频宽完全放不下彩色电视台信号，而且由于电视机已经售出，不可能更改用户家里电视的频宽和扫描线的数量。最终解决方案是在每秒 30 帧的基础上丢掉一帧，并加速 1 秒到 1.1001 秒，以保持与帧率的对齐（同时也引入了 YUV 4:2:0 色彩空间）。经过这般折腾，码率/频宽总算被压缩了下来，但后继影响了数字视频的丢帧帧率标准——为了与模拟电视兼容<a href="https://www.reddit.com/r/finalcutpro/comments/mm58qp/why_on_earth_do_we_have_2997fps_what_madness_is/">Reddit: GhostOfSorabji</a>。</p>
            <div class="align-items-center">
                <img src="files/basics/Aligning-framerates.jpg" alt="Aligning-framerates" class="img-small">
                <p class="text-gray-side mt-0">图：不同帧率的对齐问题，如果素材的帧率不统一就会出现的“快慢帧”问题，见<a href="https://www.youtube.com/watch?v=p3Jb3UPAw-w">Taran Van Hemert</a></p>
            </div>
            <p>在视频编辑中有时会遇到对齐“不同帧率”乘以“不同帧率种类”视频素材的困难问题，处理起来非常考验剪辑水平。但与其这样，不如一开始就商量好使用正确的录制设定就可以了。</p>

            <h3>逐行/交错扫描 Progressive / Interlaced</h3>
            <p>逐行扫描通过一行行从左到右地刷新像素来构建图像，是最为常用的屏幕刷新方式。交错扫描的方法不同，它使用 YUV 4:1:1 采样，将屏幕的奇数像素行视为一个场，偶数像素行视为另一个场。这两个场在录制时错开一定时间，这样在模拟电视上观看时会产生 60fps 的视觉效果。交错扫描的原理是为了节省模拟电视信号的频段区间（与收音机接收电台信号一样）。因此，通过在时间上分隔行来节省空间，可以几乎将每个频道的频宽减半，例如（<span class="text-blue-math">\(525 \text{行} \times 30\text{fps} = 15.75 \text{MHz}\)</span>）。</p>
            <div class="align-items-center">
                <img src="files/basics/PAL-NTSC-SECAM.svg" alt="PAL-NTSC-SECAM" class="img-medium">
                <p class="text-gray-side mt-0">图：NTSC，PAL 和 SECAM 播放规格的地区分布，见<a href="https://en.m.wikipedia.org/wiki/File:PAL-NTSC-SECAM.svg">维基百科</a></p>
            </div>

            <h3>音频格式（一维）</h3>
            <p>最简单的结构为——脉冲编码调制 Pulse-code modulation（PCM）信号。见<a href="https://zh.wikipedia.org/wiki/%E8%84%88%E8%A1%9D%E7%B7%A8%E7%A2%BC%E8%AA%BF%E8%AE%8A">维基百科</a>。</p>
            <table class="table-center align-items-center text-smaller">
                <thead class="thead-no-border">
                    <tr class="t-invert-dark">
                        <th class="px-1">🎶压缩</th>
                        <th class="px-1">格式</th>
                        <th class="px-1">音质</th>
                    </tr>
                </thead>
                <tbody>
                    <tr class="border-bottom">
                        <td class="px-1 t-light-gray">有损</td>
                        <td class="px-1">mp3，aac，ogg（vorbis/opus）</td>
                        <td class="px-1 t-light-gray" rowspan="3">取决于耳机/音响，混音，声场。分为 HiFi 音频和监听音频两种质量参考</td>
                    </tr>
                    <tr class="border-bottom">
                        <td class="px-1 t-invert-light">无损</td>
                        <td class="px-1">flac，alac，ape，it</td>
                    </tr>
                    <tr>
                        <td class="px-1 t-invert-dark">未压缩</td>
                        <td class="px-1">wav（PCM）</td>
                    </tr>
                </tbody>
            </table>
            
            <h3>图像格式（二维）</h3>
            <p>最简单的结构为 PCM 信号 + 每 n 个像素换行的元数据</p>
            <div class="overflow-auto">
                <table class="table-center align-items-center text-smaller">
                    <thead class="thead-no-border">
                        <tr class="t-invert-dark">
                            <th>📷压缩</th>
                            <th>格式</th>
                            <th>最大 <span style="color:red">R</span><span style="color:lime">G</span><span style="color:blue">B</span> 色深</th>
                            <th>最大 <span style="background-image: linear-gradient(190deg, rgb(68, 68, 68), white);background-clip: text; -webkit-text-fill-color: transparent;">Y</span><span style="background-image: linear-gradient(72deg, #80AB00, #8054FF); background-clip: text; -webkit-text-fill-color: transparent;">Cb</span><span style="background-image: linear-gradient(72deg, #00DB80, #FF2480); background-clip: text; -webkit-text-fill-color: transparent;">Cr</span> 色深</th>
                            <th>最大 <span style="color:aqua">C</span><span style="color:fuchsia">M</span><span
                                style="color:yellow">Y</span><span style="color:black">K</span> 色深</th>
                            <th>动图</th>
                            <th>HDR</th>
                            <th>透明</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr class="border-bottom">
                            <td class="px-1 t-light-gray">有损</td>
                            <td class="px-1">jpg</td>
                            <td class="px-1 t-light-gray">8 <span class="text-lightgray">8 8</span></td>
                            <td class="px-1">8 <span class="text-lightgray">8 8</span></td>
                            <td class="px-1 t-light-gray">24 <span class="text-lightgray">24 24 24</span></td>
                            <td class="px-1"> </td>
                            <td class="px-1"> </td>
                            <td class="px-1"> </td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-1 t-light-gray" rowspan="4">有~无损</td>
                            <td class="px-1">gif（编码无损，颜色少了）</td>
                            <td class="px-1 t-light-gray">24×3 中取 8×3</td>
                            <td class="px-1"> </td>
                            <td class="px-1 t-light-gray"> </td>
                            <td class="px-1">√</td>
                            <td class="px-1"> </td>
                            <td class="px-1">仅 1bit</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-1">webp</td>
                            <td class="px-1 t-light-gray">8 <span class="text-lightgray">8 8</span></td>
                            <td class="px-1">8 <span class="text-lightgray">8 8</span></td>
                            <td class="px-1 t-light-gray"> </td>
                            <td class="px-1">√</td>
                            <td class="px-1"> </td>
                            <td class="px-1">√</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-1">jpg-XR（兼容 jpg）</td>
                            <td class="px-1 t-light-gray">32 <span class="text-lightgray">32 32</span></td>
                            <td class="px-1">8 <span class="text-lightgray">8 8</span></td>
                            <td class="px-1 t-light-gray">16 <span class="text-lightgray">16 16 16</span></td>
                            <td class="px-1">√</td>
                            <td class="px-1">√</td>
                            <td class="px-1">√</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-1">avif，heif/heic，filf</td>
                            <td class="px-1 t-light-gray">32 <span class="text-lightgray">32 32</span></td>
                            <td class="px-1">16 <span class="text-lightgray">16 16</span></td>
                            <td class="px-1 t-light-gray"> </td>
                            <td class="px-1">√</td>
                            <td class="px-1">√</td>
                            <td class="px-1">√</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-1 t-invert-light">无损</td>
                            <td class="px-1">pdf，jpg-LS，png</td>
                            <td class="px-1 t-light-gray">16 <span class="text-lightgray">16 16</span></td>
                            <td class="px-1"> </td>
                            <td class="px-1 t-light-gray">32 <span class="text-lightgray">32 32 32</span></td>
                            <td class="px-1">仅 mng</td>
                            <td class="px-1"> </td>
                            <td class="px-1">√</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-1 t-invert-light">有损~无损~未压</td>
                            <td class="px-1">tif</td>
                            <td class="px-1 t-light-gray">16 <span class="text-lightgray">16 16</span></td>
                            <td class="px-1">8 <span class="text-lightgray">8 8</span></td>
                            <td class="px-1 t-light-gray">128 <span class="text-lightgray">128 128 128</span></td>
                            <td class="px-1"> </td>
                            <td class="px-1">√</td>
                            <td class="px-1">√</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-1 t-invert-dark" rowspan="2">未压缩</td>
                            <td class="px-1">raw，bmp</td>
                            <td class="px-1 t-light-gray">24 <span class="text-lightgray">24 24</span></td>
                            <td class="px-1"> </td>
                            <td class="px-1 t-light-gray"> </td>
                            <td class="px-1">仅 raw</td>
                            <td class="px-1">√</td>
                            <td class="px-1">√</td>
                        </tr>
                        <tr>
                            <td class="px-1">dpx</td>
                            <td class="px-1 t-light-gray">64 <span class="text-lightgray">64 64</span></td>
                            <td class="px-1">16 <span class="text-lightgray">16 16</span></td>
                            <td class="px-1 t-light-gray"> </td>
                            <td class="px-1">√</td>
                            <td class="px-1">√</td>
                            <td class="px-1"> </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>视频格式（三维）</h3>
            <p>最简单的结构为一组图片。</p>
            <div class="overflow-auto">
                <table class="table-center align-items-center text-smaller">
                    <thead class="thead-no-border">
                        <tr class="t-invert-dark">
                            <th>🎥压缩</th>
                            <th>格式</th>
                            <th><span style="color:red">R</span><span style="color:lime">G</span><span style="color:blue">B</span>/<span style="background-image: linear-gradient(190deg, black, white);background-clip: text; -webkit-text-fill-color: transparent;">Y</span><span style="background-image: linear-gradient(72deg, #80AB00, #8054FF); background-clip: text; -webkit-text-fill-color: transparent;">Cb</span><span style="background-image: linear-gradient(72deg, #00DB80, #FF2480); background-clip: text; -webkit-text-fill-color: transparent;">Cr</span> 色深</th>
                            <th>HDR</th>
                            <th>透明</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr class="border-bottom">
                            <td class="px-1 t-light-gray">有~无损</td>
                            <td class="px-1">qt，<a href="https://x265.readthedocs.io/">hevc</a>，avc，vvc，vp8/9，DNxHR/HD，prores</td>
                            <td class="px-1 t-light-gray">12 <span class="text-lightgray">12 12</span></td>
                            <td class="px-1">除 avc，vp8</td>
                            <td class="px-1">仅 prores</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-1 t-invert-light" rowspan="2">无损</td>
                            <td class="px-1">rawvideo</td>
                            <td class="px-1 t-light-gray">32 <span class="text-lightgray">32 32</span></td>
                            <td class="px-1"> </td>
                            <td class="px-1">√</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-1"><a href="https://github.com/marksfink/cfenc">cineform</a></td>
                            <td class="px-1 t-light-gray">16 <span class="text-lightgray">16 16</span></td>
                            <td class="px-1">√</td>
                            <td class="px-1"> </td>
                        </tr>
                        <tr>
                            <td class="px-1 t-invert-dark">有损~无损~未压</td>
                            <td class="px-1">Flash 动画</td>
                            <td class="px-1 t-light-gray" colspan="3">内嵌图片决定</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h4>动图 vs 视频 vs 图片序列</h4>
            <p>图片与视频之间还有图像序列，动图两种中间格式。图像序列直接储存视频为大量图像，一般用于录制素材；动图如 .gif，.mng 则表面上和视频一致：</p>
            <table class="table-center align-items-center">
                <thead>
                    <tr>
                        <th class="px-1">设计\格式</th>
                        <th class="px-1">动图编码</th>
                        <th class="px-1">视频编码</th>
                        <th class="px-1">图片序列</th>
                    </tr>
                </thead>
                <tbody>
                    <tr class="border-bottom">
                        <td>播放用时</td>
                        <td>短（GOP = 1）</td>
                        <td>长（GOP &gt;= 1）</td>
                        <td>无</td>
                    </tr>
                    <tr class="border-bottom">
                        <td>帧率</td>
                        <td>随便</td>
                        <td>随便</td>
                        <td>随便</td>
                    </tr>
                    <tr class="border-bottom">
                        <td>分辨率</td>
                        <td>随便</td>
                        <td>随便</td>
                        <td>随便</td>
                    </tr>
                    <tr class="border-bottom">
                        <td>帧间冗余</td>
                        <td>一般不支持</td>
                        <td>一般都支持</td>
                        <td>无</td>
                    </tr>
                    <tr>
                        <td>需要封装</td>
                        <td>无</td>
                        <td>一般都需要</td>
                        <td>无</td>
                    </tr>
                </tbody>
            </table>

            <h3>滤镜/滤波器 Filter 与滤镜工具</h3>
            <p>通常用于过滤水和净化空气。在信号中代表处理一维音频和二维视频信号的算法。滤镜工具代表能够将滤镜应用到信号上的软件或插件，比如 Adobe Premiere Pro，After Effects，<a href="https://ffmpeg.org/">ffmpeg</a>，<a href="https://www.blackmagicdesign.com">DaVinci Resolve</a>，<a href="https://www.screentogif.com/">ScreenToGIF</a>，<a href="https://www.image-line.com">FL Studio</a>，<a href="https://www.reaper.fm/">Reaper</a>，<a href="https://www.ableton.com/">Ableton</a>，Audition，<a href="https://www.gimp.org/">GIMP</a>，Photoshop，<a href="https://www.faststone.org/FSCaptureDetail.htm">FSCapture</a>，LightRoom，OpenCV 等编辑图像、视频和音频的工具。<a href="https://avs-plus.net/">AviSynth(+)</a>和 VapourSynth 严格上称为帧服务器，因为需要连接一个编码器才能导出视音频。</p>

            <h3>噪声 Noise 与颗粒 Grain</h3>
            <p>电影胶片（卤化银晶体）被投影灯放大得到胶片颗粒 Film Grain，在单独一帧胶片画面上是一种比较自然静态噪声。更广义且不自然的噪声来自于电视信号接收器或相机使用放大电路 amplifier 放大无信号频段，或黑暗场景产生的“雪花”画面和声音。以及根据厂家镀膜工艺水平而定的显示器屏幕磨砂表面“静态噪声”等等。</p>
            <p>一般来说，如果噪点的边角尖锐，缺乏渐变，则属于“难看的噪声”。另一种比较极端的判断方法是——只有影视导演亲手保留，或游戏美工专门根据显示技术适配处理过的噪声才是好看的噪声、由第三方私自添加的噪声是“难看的噪声”。</p>
            <p class="text-gray-side">实际上，人眼的“成像技术”也决定了人看到的画面本来就有很多噪点，而且是动态噪点，只是未注意的时候都是大脑的实时降噪和幻觉在抑制而已。</p>
            <div class="align-items-center">
                <img src="files/basics/imax-tape-projector.jpg" alt="imax-tape-projector" class="img-medium">
                <p class="text-gray-side">图：正在放映 2023 年电影《奥本海默》的 70mm IMAX 胶片放映机。源：<a href="https://www.cnbc.com/2023/07/19/where-to-watch-oppenheimer-in-70mm-imax-.html">Nicolas Vega</a></p>
                <img src="files/basics/matte-vs-glossy.jpg" alt="matte-vs-glossy" class="img-medium">
                <p class="text-gray-side">图：同一个 OLED 面板前方使用磨砂镀膜与镜面镀膜的微观区别。可以看到没有漫反射的镜面更“通透”。当然，后者的纯色光更容易聚集，LED 调整亮度所必须的频闪亮度变化也更大，容易导致眼部刺痛、散光。源：<a href="https://www.youtube.com/watch?v=mZjxEcuVHlQ">The Display Guy</a></p>
            </div>

            <h3>抖动滤镜 Dither Filter</h3>
            <p>源自早期操作系统只能显示有限数量的颜色，因此采用了高频闪烁两种颜色的方法来欺骗视觉（副作用是使人感到晕眩）。在图像、音频和低端显示器中，抖动滤镜代表通过分辨率或采样率来换取位深的加噪补偿手段。</p>
            <button type="button" class="collapsible border-main rounded-3">点击展开/折叠内容：常用的抖动滤镜，可略</button>
            <div class="coll-content">
                <p>具体来说，通过间隔几个像素就调亮/调暗一个像素的颜色，使得宏观整体上看起来像是淡化或加深；在音频位深分量两端的采样点间成比例的（以方形波或三角波信号）快速摆动，从而利用扬声器反应速度，起到淡化或深化偏移宏观上位深的效果。</p>
                <div class="align-items-center">
                    <img src="files/basics/Audio-Dither.png" alt="Audio-Dither" class="img-medium">
                    <p class="text-gray-side mt-0">图：音频的采样点，以及下采样音频，抖动关对比开的效果，见<a href="https://micoope.com.gt/?s=what-is-audio-dithering-and-why-it-s-used-aa-BaD6b0T5">Micoope 科普</a>。</p>
                    <img src="files/basics/Image-Dither-1.png" alt="Dither-1" class="">
                    <p class="text-gray-side mt-0">图：下采样 8bit 到 1bit，开抖动的效果</p>
                </div>
                <p>抖动滤镜的效果主要是欺骗视觉，但因为效果独特，所以衍生出了 Ditherpunk 抖动朋克美术。典型如 1bit 游戏《奥博拉丁的回归》贯彻了这种风格——利用<a href="https://bartwronski.com/2016/10/30/dithering-part-one-simple-quantization/">随机</a>，<a href="https://bartwronski.com/2016/10/30/dithering-part-two-golden-ratio-sequence-blue-noise-and-highpass-and-remap/">蓝噪声</a>，<a href="https://bartwronski.com/2016/10/30/dithering-part-two-golden-ratio-sequence-blue-noise-and-highpass-and-remap/">蓝噪声，黄金分割</a>，<a href="https://www.compuphase.com/riemer.htm">Riemersma</a> 等不同的加噪算法来定义游戏引擎的材质。</p>
                <div class="align-items-center">
                    <img src="files/basics/Image-Dither-2.png" alt="Dither-2" class="img-medium">
                    <p class="text-gray-side mt-0">图：图像噪声算法</p>
                </div>
            </div>

            <h3>缩放滤镜 Resize Filter</h3>
            <p>Windows 系统一般用双线性缩放放大 PPI 小的软件，视频视频播放器一般用 bicubic 或 lanczos 插值</p>
            <button type="button" class="collapsible border-main rounded-3">点击展开/折叠内容：更改图像大小的各种算法，可略</button>
            <div class="coll-content">
                <h5>临近取样插值 Nearest Neighbour interpolation（NN）：</h5>
                <ol class="text-smaller">
                    <li>2x2 的四个像素点移动到缩放后的四个位置</li>
                    <li>待插值的像素中，距离哪四个点近的像素就取哪个像素的值</li>
                </ol>
                <h5>双线性插值 Bi-linear interpolation（Bi-lerp / Bilinear）：</h5>
                <ol class="text-smaller">
                    <li>2x2 的四个像素点移动到缩放后的四个位置</li>
                    <li>横向和纵向的点（像素值）间各连一条线</li>
                    <li>采样得到中间的像素，完成四边的插值</li>
                    <li>四边之间接着分为横向与纵向边缘</li>
                    <li>横向和纵向的边（像素值）间各连一条线，共六横六纵</li>
                    <li>所有线段接着采样得到中间的插值像素点，且在横纵线的两种插值之间取平均</li>
                </ol>
                <h5>样条插值 Spline interpolation（spline）：</h5>
                <ol class="text-smaller">
                    <li>“样条”代表软木条，通过铁钉塑形结合木条的应力做出连贯且一致的曲线</li>
                    <li>这种性质可以用多项式准确描述，而图像中的“铁钉”就是像素值</li>
                    <li>图像中的“木条”就是在 n 个“铁钉”构成的 n-1 个区间里各画一条曲线</li>
                    <li>二次多项式插值 quadratic interpolation 代表三个点间用二次多项式插值</li>
                    <li>三次多项式插值 cubic interpolation 代表四个点间用三次多项式插值，适用于放大图像</li>
                    <li>连起的线必须平滑连贯，数学上叫做“二阶导数连续”
                        <ul>
                            <li>因此，放大一个 2x2 的区间需要 4x4 范围的采样点</li>
                        </ul>
                    </li>
                    <li>插值的与逻辑和双线性插值一致，同时是三次多项式插值，则是双三次多项式插值 bi-cubic interpolation</li>
                </ol>
                <h5>Lanczos 插值：</h5>
                <p class="text-smaller">使用 sinc 函数取近似，且引入了窗函数来矫正 sinc 函数，同时要计算 lanczos 核实现插值。计算量大，准确度略高于 bicubic 插值。</p>
                <h5>神经网络缩放滤镜：</h5>
                <p class="text-smaller">通过认知大量训练数据，在其中找出更高维度规律的情况下，利用这些规律推断像素值。计算量极大，准确度时高时低。</p>
            </div>

            <h3>宽高比 Aspect Ratio</h3>
            <p>矩形的最小两边的比例，被中国航空航天称为展弦比。被忽略的“长”是屏幕相对人眼的 z 轴。而换算长短边如 16:9 高 720 的方形像素视频，其宽就是 <span class="text-blue-math">\( 720 \div 9 \times 16 = 1280 \)</span>。</p>
            <div class="align-items-center">
                <img src="files/basics/Aspect-Ratio-16-by-9.png" alt="Aspect-Ratio-16-by-9" class="img-medium">
                <p class="text-gray-side mt-0">图：16:9 的矩形整数偶数放大后的图像分辨率</p>
            </div>
            <p>图片格式一般支持奇数分辨率，视频一般仅支持偶数分辨率。</p>

            <h3>高/低频 High/Low frequency</h3>
            <p>假设函数 <span class="text-blue-math">\(y=\cos\left(ux\right)\)</span>。可以调节变量 u，如 <span class="text-blue-math">\(y=\cos\left(2x\right)\)</span>，<span class="text-blue-math">\(y=\cos\left(3x\right)\)</span>  等。u 越大则余弦函数周期越短——频率越高；u 越小则余弦函数周期越长——频率越低。</p>
            <p>变换算法可以将这个 u 作为输出数轴，原始波形中从低频到高频的分量都会被准确地排列进来。</p>

            <h3>程序的交互界面 Interface</h3>
            <p><b>图形界面交互 Graphic user interface GUI</b>：通过图形元素（如按钮、滑块、菜单等）进行用户交互的界面设计。随着程序复杂度的增加，设计出好用的界面会变得更加困难。因此，只有在利润丰厚、注重美学设计、且拥有设计人才的行业才会推出外观精美的 GUI。然而，外观好看并不一定意味着好用、再而，很多时候有外观用都是一种奢求。
            </p>
            <div class="align-items-center">
                <img src="files/basics/FL-Studio-GUI-Demonstration.png" alt="FL-Studio-GUI-Demonstration" class="img-medium">
                <p class="text-gray-side mt-0">图：音频插件宿主软件 FL Studio，外加一堆免费和“免费”音频插件随便摆放的外观</p>
                <img src="files/basics/XAMPP-GUI-Demonstration.png" alt="XAMPP-GUI-Demonstration" class="img-medium">
                <p class="text-gray-side mt-0">图：网页服务器宿主软件 XAMPP 的 GUI（左下为 CLI），作为跨行业对比</p>
            </div>
            <p><b>命令行交互 Commandline interface CLI</b>：在如 Terminal、Bash、CMD 和 PowerShell 的终端环境中，用户可以手动输入命令并按回车键查看结果。通常，只要输出结果有一定的文本排版，就可以轻松阅读。随着使用的增加，CLI 可能反而会变得比 GUI 更方便。然而，由于某些命令太长，而且需要储存变量，因此为了简化操作，人们会将其写作批处理、Shell 等命令脚本文件。例如<a href="https://nazorip.site/archives/835/">PowerShell 一站式系统硬件检测</a>的脚本。</p>
            <div class="align-items-center">
                <img src="files/basics/Ubuntu-Terminal.png" alt="Ubuntu-Terminal" class="img-medium">
                <p class="text-gray-side mt-0">图：Ubuntu（Linux 系统）的终端命令交互程序窗口。</p>
            </div>
            <p><b>应用编程交互 Application programming interface API</b>：定义编译好的软件应用程序之间应该如何如何相互通信的规则。主要分为跨网络的 API（调用数据库、调用其他网站资源）和本地程序之间（软件、操作系统、电脑硬件）的 API。API 可以被看作是 CLI 的映射。</p>

            <h2 id="h2-2">编解码的过程</h2>
            <p>注：实际情况下会因为软硬件，用户设定，以及操作系统逻辑的不同而变。</p>
            <h3>视频的打开</h3>
            <ol>
                <li>用户点击打开视频文件</li>
                <li>操作系统根据文件扩展名，查找默认的应用程序</li>
                <li>应用程序根据文件路径，在文件系统中定位视频，并读取文件的元数据，包括文件头和其他格式信息</li>
                <li>应用程序根据文件的元数据确定所需的解码器和其他资源，然后在计算机的内存中分配空间</li>
                <li>应用程序调用适当的解码器来解析视频文件，并将视频和音频数据解码为未压缩的原始数据</li>
                <li>解码后的视频数据传递给图形处理芯片 GPU，而音频数据则传递给声音转换芯片 DAC。</li>
                <li>GPU 将图像信号转换为图像，输出到显示器</li>
                <li>显示器上的芯片将图像数据转换为对每个像素上电路的控制，并显示出来</li>
                <li>DAC 将音频信号转换为模拟信号，并通过扬声器播放出来</li>
            </ol>
            
            <h3>视频的压制</h3>
            <ol>
                <li><b>打开编码器</b>
                    <ul>
                        <li>用户可以通过多种方法打开编码器：
                            <ul class="text-smaller">
                                <li>如果编码器内置了如 Lavf 的解封装和解码动态链接库，则编码器可以自动解封装、解码和封装视频文件：
                                    <ul class="text-smaller">
                                        <li>GUI 软件通过发送 CLI 命令，或者使用像 Bash/CMD 这样的 CLI 工具来打开编码器程序。</li>
                                        <li>编码器通常根据输出文件的后缀名自动封装视频文件。</li>
                                    </ul>
                                </li>
                                <li>如果编码器没有内置解封装解码功能，则通常会使用 ffmpeg 内部的解封装工具和编码器。
                                    <ul>
                                        <li>可以使用 pipe 将上游如 ffmpeg、VapourSynth、avs2yuv 连接到下游如 x264/5 的编码器</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><b>解封装和解码</b>
                    <ul>
                        <li>解封装解码工具将已解压缩的 YUV for MPEG 或 RAW 格式视频流传递给编码器，编码器得到输入信号。
                            <ul class="text-smaller">
                                <li>如果输入是 RGB24 的 RAW 色彩空间视频流，通常需要使用编码器内置的色彩空间转换功能将其转换为 YUV 格式。</li>
                                <li>如果编码器是录像设备的一部分，则需要根据录像设置将视频流拆分为视频帧。</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><b>编码过程</b>
                    <ul>
                        <li><b>前瞻进程</b>：Lookahead 从更小的分辨率预先分析未来几帧的复杂度、运动和场景切换 scenecut 的估计。</li>
                        <li><b>分帧/帧类型决策</b>：根据前瞻进程的结果和关键帧间隔 keyframe interval 设置关键帧 I 帧与参考帧 P-B 帧。</li>
                        <li><b>粗分块</b>：
                            <ul>
                                <li>x264 中粗分到宏块 Macroblock MB</li>
                                <li>x265 中粗分到编码树单元 Coding Tree Unit CTU </li>
                            </ul>
                        </li>
                        <li><b>动态搜索</b>：Motion Estimation（ME）找到当前帧与参考帧之间的相似区域，并为每个块分配动态向量。</li>
                        <li><b>运动补偿</b>：Motion Compensation（MC）对比实际画面与搜索到的向量生成预测块，并补偿¼子像素精度的对齐偏差。</li>
                        <li><b>细分块</b>：根据 MEMC，进一步细分宏块或编码树单元到最小的 4x4 编码块上。</li>
                        <li><b>帧间残差编码</b>：对比实际画面与动态搜索与补偿后所得的图像，得到残差，并对残差进行变换和量化，存储到 P-B 帧上，在解码时与 I 帧叠加以得到原始画面。</li>
                        <li><b>帧内预测</b>：在帧内编码块上检查候选出冗余最好的帧内编码方法（夹角、DC、趋平、无），选中方法后得到帧内预测后的块，即预测块。
                            <ul><li>开启率失真优化则进一步检查画质同码率下画质是否也最好</li></ul>
                        </li>
                        <li><b>帧内残差编码</b>：对比实际画面与帧内预测得到的残差块，进行变换和量化，存储在预测块中，在解码时与预测模式叠加以得到原始画面。</li>
                        <li><b>跳过块编码</b>：跳过帧间或帧内残差编码的块，进行变换和量化。</li>
                        <li><b>变换</b>：将图像从空间域转换到低频到高频信号分量之间的每个级别，也称为频域。</li>
                        <li><b>量化</b>：根据用户设置的质量级别，削减高频信号分量，这一步骤对画质和文件大小影响最大。</li>
                        <li><b>熵编码/文本编码</b>：将变换和量化后的频域分量统计为最小可能的二进制数。</li>
                    </ul>
                </li>
                <li><b>生成视频流</b>
                    <ul>
                        <li>编码器将生成的数据流逐个 GOP Group of Pictures 打包为文件，得到完整视频流文件</li>
                        <li>如有必要，附加如色彩空间、Supplemental Enhancement Information SEI、VUI、HDR 等元数据</li>
                    </ul>
                </li>
                <li><b>封装视频流</b>
                    <ul>
                        <li>用户可以通过多种方法将视频流封装为 .mp4、.mkv、.mov 等格式：
                            <ul class="text-smaller">
                                <li>如果编码器内置了像 Lavf 的解封装解码动态链接库，编码器可以根据输出命令行的文件后缀名自动完成。</li>
                                <li>如果编码器没有内置解封装解码功能，则通常会使用 ffmpeg 内部的编码器和解封装工具，使编码完成后自动封装。</li>
                                <li>可以使用工具如 <a href="http://ffmpeg.org/download.html">ffmpeg</a>、<a href="https://www.videohelp.com/software/MP4Box">MP4Box</a>，<a href="https://mkvtoolnix.download/">MKVToolNix</a> 等来进行封装。</li>
                            </ul>
                        </li>
                        <li>封装文件使得播放器的程序逻辑变得简单（例如，在读取视频流之前就获取视音频格式，而不是先打开所有解码器，再关掉不兼容的解码器）</li>
                        <li>如有必要，附加音频流/音轨、字幕轨、字体等文件（但要根据封装文件的兼容性判断）</li>
                    </ul>
                </li>
            </ol>
            <div class="align-items-center">
                <img src="files/basics/Video-Endocing-Process.png" alt="Video-Endocing-Process" class="img-medium">
            </div>

            <h3>视频编码的标准（<a href="https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Video_codecs">MDN Docs</a>）</h3>
            <p>Encoding Standard 一般称为 Codec。</p>
            <div class="overflow-auto">
                <table class="table-center align-items-center text-smaller">
                    <thead>
                        <tr>
                            <th scope="row">♙编码</th>
                            <th scope="col">全称</th>
                            <th scope="col">一般封装格式</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr class="border-bottom">
                            <th scope="row">AV1</th>
                            <td>AOMedia Video 1</td>
                            <td>MP4，WebM，MKV</td>
                        </tr>
                        <tr class="border-bottom">
                            <th scope="row">AVC (H.264)</th>
                            <td>Advanced Video Coding</td>
                            <td>3GP，MP4</td>
                        </tr>
                        <tr class="border-bottom">
                            <th scope="row">H.263</th>
                            <td>H.263 Video</td>
                            <td>3GP</td>
                        </tr>
                        <tr class="border-bottom">
                            <th scope="row">HEVC (H.265)</th>
                            <td>High Efficiency Video Coding</td>
                            <td>MP4</td>
                        </tr>
                        <tr class="border-bottom">
                            <th scope="row">MP4V-ES</th>
                            <td>MPEG-4 Video Elemental Stream</td>
                            <td>3GP，MP4</td>
                        </tr>
                        <tr class="border-bottom">
                            <th scope="row">MPEG-1</th>
                            <td>MPEG-1 Part 2 Visual</td>
                            <td>MPEG，QuickTime</td>
                        </tr>
                        <tr class="border-bottom">
                            <th scope="row">MPEG-2</th>
                            <td>MPEG-2 Part 2 Visual</td>
                            <td>MP4，MPEG，QuickTime</td>
                        </tr>
                        <tr class="border-bottom">
                            <th scope="row">Theora</th>
                            <td>Theora</td>
                            <td>Ogg</td>
                        </tr>
                        <tr class="border-bottom">
                            <th scope="row">VP8</th>
                            <td>Video Processor 8</td>
                            <td>3GP，Ogg，WebM</td>
                        </tr>
                        <tr>
                            <th scope="row">VP9</th>
                            <td>Video Processor 9</td>
                            <td>MP4，Ogg，WebM</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p>其中，“H.264”的 H 代表国际电信联盟 - 电信标准化部门（ITU‑T）中的 <a href="https://www.itu.int/net/itu-t/sigdb/spevideo/Hseries-s.htm">H 系列建议指南</a>，例如 <a href="https://www.itu.int/rec/T-REC-H.810">ITU-T H.810</a> 个人健康系统（血压计、血糖仪、体重秤）的交互设计建议指南。一些符合某个 H 系列视频编码建议指南的视频编码器会将这个标号写在程序名字上，就有了所谓的 x264，x265。</p>
            <div class="align-items-center">
                <img src="files/basics/Video-Endocing-Standards.png" alt="Video-Endocing-Standards" class="img-medium">
            </div>

            <h3>命令行参数</h3>
            <p>由开发者定义，将函数或程序中的一些变量设为通过命令传递。命令行参数一般使用空格作为分隔符（也有用半角冒号，半角句号等其他情况），参数和参数值之间一般使用空格做分隔符（也有使用等于号的其他情况），多个参数值之间一般使用半角逗号或半角冒号分隔，而含有空格的参数值则使用半角直引号 "" 或 '' 连起来。</p>
            <p>例如，x264 使用 CLI 参数的例子：</p>
            <code>x264.exe <span class="text-blue-emph">--rc-lookahead 90 --bframes 12 --b-adapt 2 --me umh --subme 9 --merange 48 --no-fast-pskip --direct auto --weightb --keyint 360 --min-keyint 5 --ref 3 --crf 20 --qpmin 9 --chroma-qp-offset -2 --aq-mode 3 --aq-strength 0.7 --trellis 2 --deblock 0:0 --psy-rd 0.77:0.22 --fgo 10 --nr 4</span> --output ".\输出.mp4" ".\导入.mp4"</code>
            <p>以及 ffmpeg 中使用 CLI 参数启用 libx264，通过 <code>-x264-params</code> 发送 API 参数的例子：</p>
            <code>ffmpeg.exe -loglevel 16 -hwaccel auto -y -hide_banner -i ".\导入.mp4" -c:v libx264 -x264-params "<span class="text-blue-emph">rc-lookahead=90:bframes=12:b-adapt=2:me=umh:subme=9:merange=48:fast-pskip=0:direct=auto:weightb=1:keyint=360:min-keyint=5:ref=3:crf=20:qpmin=9:chroma-qp-offset=-2:aq-mode=3:aq-strength=0.7:trellis=2:deblock=0,0:psy-rd=0.77,0.22:nr=4</span>" -fps_mode passthrough -c:a copy ".\输出.mp4"</code>
            <p>ffmpeg 中，导入文件由 <code>-i</code> 参数完成，因为 ffmpeg 支持导入多个文件，而每个文件后跟随一些处理命令就需要较为严格的命令添加顺序，而 x264/5 这些编码器一般只是导入一个文件，所以在末尾加一个路径到文件的字符串就代表导入文件了。</p>
            <div class="align-items-center">
                <img src="files/basics/Encoding-CLI-Info.png" alt="Encoding-CLI-Info" class="img-medium">
                <p class="text-gray-side">图：使用命令行窗口启动视频压制命令后，视频编码器会给出大致这些信息</p>
            </div>

            <h3>本教程中命令行参数的说明格式</h3>
            <code class="code-bold">--参数</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;开关 | 整数 A~B | 浮点 A~B | 其它格式，默认值，<span class="text-red-emph">限制</span>&gt;说明信息，特点注解，推荐<span class="text-blue-emph">这个值</span>，其它情况可设<span class="text-blue-emph">这个值</span>。</p>
            <ul class="font-monospace pl-5 text-smaller">
                <li>情况 1：特点如此，推荐<span class="text-blue-emph">这个值</span></li>
                <li>情况 2：特点如此，推荐<span class="text-blue-emph">这个值</span></li>
            </ul>

            <h3>管道 Pipeline</h3>
            <p>一种在进程/软件之间通信的操作系统机制。在命令行中写作通过链接符 <span class="text-blue-emph">|</span> 串联起来是两段命令，而两段命令间的数据一般由默认输出 standard output（stdout）和默认输入 standard input（stdin）实现，因此不需要手动添加输出和输入命令。报错则为 stderr。在涉及到文件输入输出的程序时则需要手动指定“-”符号到程序的输入命令中，以取代文件的输入。</p>
            <h4>串流管道 Stream-based pipe</h4>
            <p>Windows CMD、Linux Bash 的管道模式，用于传输纯数据，其中的程序同步运行，持续地传输上游输出到下游。适用于串流作业和处理流数据，包括视音频和文本流。</p>
            <h5>串流管道详解</h5>
            <p>Linux Bash 中使用 <code>for txt in *.txt; do md5sum $txt; done | awk '{print $2, $1}' | sort -bn</code> 代表：</p>
            <ul class="text-gray-side">
                <li>在当前命令行目录下遍历 .txt 文件，生成多行“哈希值 文件名”字符串</li>
                <li>将文本流传给排列功能，将每行字符的顺序改为“文件名 哈希值”</li>
                <li>将文本流传给排序功能，按照文件名的数字重排行号并忽略空格，得到按顺序排版的“文件名 哈希值”</li>
            </ul>
            <h4>对象管道 Object-based pipe</h4>
            <p>PowerShell 的管道模式，用于传输结构化的对象（变量本身），而不是纯数据。其中的程序按顺序接力，一个程序/协议/函数跑完后再打开下一个。适用于处理对象化数据（面向对象的应用），所以不适合用于处理视音频流文件。</p>
            <h4>指定默认输入和报错</h4>
            <code>J:\ffmpeg.exe -i D:\文件夹\源.mp4 -an -f yuv4mpegpipe - | J:\x264-r3206.exe --y4m - --output D:\文件夹\测试.h264 <span class="text-blue-emph">2> D:\文件夹\报错.txt</span></code>
            <p>以上命令代表在 Windows CMD 中：</p>
            <ol>
                <li>ffmpeg 导入 "D:\文件夹" 下的一个视频文件</li>
                <li>ffmpeg 使用 <code>-an</code> 命令指定关闭音频编码</li>
                <li>ffmpeg 使用 <code>-f</code> 命令指定使用 YUV For MPEG 管道格式，相对于 rawpipe 格式提供了一些视频元数据，使 x264 了解视频的分辨率、帧率、位深等基本参数，否则需在命令行中手动指定</li>
                <li>ffmpeg 使用“-"替代文件路径，指定导出文件到管道</li>
                <li>x264 使用 <code>--y4m -</code> 命令指定使用 YUV For MPEG 管道格式，并设定输入流为“-”</li>
                <li>x264 导出压制出、未封装的视频流到 <code>D:\文件夹</code> 下</li>
                <li>x264 导出任何可能的报错信息到 <code>D:\文件夹</code> 下，以避免管道上游的信息覆盖或埋藏</li>
            </ol>
            <h4>管道的问题与上位替代</h4>
            <ul>
                <li>管道下游程序的报错常被管道上游覆盖或埋藏，需要额外指定报错信息导出路径</li>
                <li>虽有编程爱好者集成 LAVF 编解码到 x264 编码器中（封装、解封装视频流功能），但不是所有视频编码器都受到这种待遇</li>
                <li>视频流已经占据了管道，音频流的封装就需要等第二行命令实现了</li>
                <li>同理，若视频编码命令出错，那么自动化脚本中的封装命令也会失败，使得原本的报错信息更难找到</li>
            </ul>
            <p>而上面的命令可以被简化到直接调用 ffmpeg 内置的 libx264 库，从而用一条命令实现压制与封装：</p>
            <code>J:\ffmpeg.exe -i D:\文件夹\源.mp4 -c:v libx264 -fps_mode passthrough -c:a copy D:\文件夹\输出.mp4</code>
            <p>这种命令行环境下，要注意音频流与封装格式的兼容性。如果要替换或添加新音频轨道，则在 ffmpeg 命令行中输入音频流，并通过 <code>-map</code>、<code>-c</code> 命令指定替换或添加。</p>

            <h2 id="h2-3">数据结构</h2>
            <h3>帧的结构</h3>
            <p>在 Advanced Video Coding AVC 中，帧的下级结构按照分辨率大小分为条带组 slice group → 条带 slice → 宏块 Macroblock → 块 block。从大小和功能上细分为：</p>
            <ul>
                <li><b>帧 frame</b>：
                    <ul class="text-smaller">
                        <li><b>关键帧</b>：I/i 帧</li>
                        <li><b>参考帧</b>：P 帧、B/b 帧</li>
                    </ul>
                </li>
                <li><b>条带组 slice group</b>：
                    <ul class="text-smaller">
                        <li>由灵活宏块排序 Flexible Macroblock Ordering FMO 划分</li>
                        <li>优化解码延迟，提高压缩和参考错误恢复能力</li>
                    </ul>
                </li>
                <li><b>条带 slice</b>：
                    <ul class="text-smaller">
                        <li><b>关键帧下</b>：I/i 条带</li>
                        <li><b>参考帧下</b>：I/i 条带、P 条带、B/b 条带</li>
                        <li>空条带：填充网络数据包中，数据不足而无法填满的空位</li>
                        <li>冗余条带：提高数据抗丢包，抗损坏的能力</li>
                    </ul>
                </li>
                <li><b>宏块 Macroblock</b>：
                    <ul class="text-smaller">
                        <li>粗分块，在动态搜索与补偿前完成，面积为 16x16 像素</li>
                    </ul>
                </li>
                <li><b>块 Block</b>：
                    <ul class="text-smaller">
                        <li>细分块，在动态搜索与补偿后完成，面积为 8x8 或 4x4 像素</li>
                        <li><b>关键帧下</b>：帧内预测块、帧间预测块</li>
                        <li><b>参考帧下</b>：帧内预测块、帧间预测块、帧内残差块、帧间残差块</li>
                        <li><b>帧间预测块</b>：将 I 块叠加帧间动态矢量后变出的帧间预测画面</li>
                        <li><b>帧内预测块</b>：从块左侧和顶部的一排相邻像素上，叠加插值算法变出的帧内预测画面</li>
                        <li><b>残差块</b>：保存帧间和帧内预测无法还原的信息，与预测宏块叠加用。画面复杂则“残差才是本体”</li>
                    </ul>
                </li>
            </ul>
            <div class="align-items-center">
                <img src="files/basics/Video-Coding-Components.png" alt="Video-Coding-Components" class="img-medium">
            </div>

            <h3>GOP 结构</h3>
            <p>而相对的，在帧之上的结构被称为图组 Group of pictures。每个 GOP 的创建取决于关键帧间隔设置以及转场判断，其中都包含了 IDR 帧，i 帧，P 帧，Pyramid-B 帧以及 b 帧。一个视频中最少由一个 GOP 组成，同视频长度下 GOP 的数量越多则视频体积越大，解码难度越低。</p>
            <ul>
                <li><b>关键帧 IDR 帧，I 帧</b>：
                    <ul>
                        <li><b>I 帧 Intra-coded frame</b>独立编码，不依赖于其他帧的关键帧。也可以作为解码的起始点，只是不会刷新参考帧列表，所以强行播放可能会有一些画面错误
                            <ul class="text-smaller">
                                <li>“关键”代表“起到独立解码，随机访问点 Access point，传输错误后重新同步视频流，集中参考源以提高压缩率等关键作用”</li>
                            </ul>
                        </li>
                        <li><b>即时解码刷新 Instantaneous Decoder Refresh 帧</b>是一种带有刷新标记的特殊 I 帧，解码器播放到 IDR 帧时会刷新参考帧列表，因此 IDR 帧之前的帧不再作为参考源，从而隔离了 GOP。</li>
                        <li>IDR 帧一般位于 GOP（Group of Pictures）之首。用户拖动进度条时，解码器会寻找最近的 IDR 帧解码</li>
                        <li>IDR 帧与 I 帧同为关键帧，有时会被写作 I 帧与 i 帧</li>
                        <li>IDR 帧数量过少时，可能会导致以下问题：
                            <ul class="text-smaller">
                                <li>随机访问会导致参考错误 + 长时间无法纠正画面错误：P，B，b 帧会尝试参考 i 帧之前的帧</li>
                                <li>剪辑困难：专业视频编辑软件会在剪辑视频时会插入新的 IDR 帧以保证预览流畅和准确</li>
                                <li>随机访问困难，因为 GOP 的基础结构不存在，拖动进度条需要从视频开头解码到新的位置以后才能播放</li>
                                <li>拖动进度条代表需要从很远的 IDR 帧（无 IDR 帧则从视频开头）解码到新的位置再继续，等待的时间变得漫长，播放设备的发热增加</li>
                                <li>如果播放器关闭了拖动进度条的精确索引，则拖动进度条会导致进度条位置偏移到其之前很远的 IDR 帧上，或返回开头</li>
                            </ul>
                        </li>
                        <li>如果 I 帧数量过少，则会有一串含有 I 条带的 P 帧替代它</li>
                        <li>IDR 帧的数量由 Keyframe interval <code>--keyint</code> 参数和 <code>--scenecut</code> 参数决定</li>
                        <li>I 帧的数量由 <code>--min-keyint</code> 参数决定</li>
                    </ul>
                </li>
                <li><b>参考帧 P/B-Pyramid/b 帧</b>：
                    <ul class="text-smaller">
                        <li>参考帧 P 帧 Prediction frame 含有 I 条带与 P 条带，全部条带都可以给临近的 P，B 帧参考</li>
                        <li>双向参考帧 Bi-directional prediction frame，b 帧含有 i，P，B 条带，只有 i 条带可以给临近的 P，B 帧参考</li>
                        <li>尖塔 B 帧 Pyramid bi-directional prediction frame 含有 I，P，B 条带，全部条带都可以给临近的 P，B 帧参考</li>
                    </ul>
                </li>
            </ul>

            <h4>多参考帧的结构</h4>
            <p>x264 首次引入了超过前后一帧长度的帧间参考范围。因此动态搜索也能更好的检查运动向量的时间一致性，从而减少动态噪点对动态搜索的干扰，同时提高了压缩。多参考帧不是越长越好，而是只要满足「一帧只要参考前后各 n 帧的信息就足以还原自身」的长度就是对的，而超过后会导致视频体积增加，同时画质降低。这个长度一般是前后各 3 帧，</p>

            <h2 id="h2-4">前瞻进程 Lookahead</h2>
            <p>最先启动，设立关键帧和参考帧，决定了 GOP 划分的初始编码步骤。决定了后续所有步骤的大纲：</p>
            <ol>
                <li><b>启动和初始化</b>：
                    <ul class="font-monospace pl-5 text-smaller">
                        <li>从视频或 <code>--seek</code> 参数指定的位置开始，顺序导入视频帧到 Lookahead 过程</li>
                        <li>导入的视频帧会被缩小一半以提高速度</li>
                        <li>后续步骤发现 GOP 结尾时，当前的 Lookahead 帧列表（<code>h-&gt;Lookahead-&gt;next-&gt;list</code> ）会更新 Lookahead 起点。</li>
                    </ul>
                </li>
                <li><b>软转场（Scenecut）</b>：
                    <ul class="font-monospace pl-5 text-smaller">
                        <li>如果输入的首帧是自动 AUTO 模式或 I 帧，则设为 IDR 帧</li>
                        <li>如果使用 <code>--no-open-gop</code>，且输入帧与之前的非 B 帧画面差距达到 <code>--scenecut</code> 阈值触发转场，则设立 IDR 帧以建立新的 GOP</li>
                        <li>IDR 帧（于 <code>--min-keyint</code> 范围内则设 I 帧）的前一帧会被强制改为 P 帧，以阻止 B 帧的双向参考特性</li>
                    </ul>
                </li>
                <li><b>启用/关闭连续 B 帧</b>：
                    <ul class="font-monospace pl-5 text-smaller">
                        <li>排除了设立 I/i 帧的可能后，还剩下 GOP 长度减 1 的帧数量没有被分配帧类型。</li>
                        <li>此时不考虑 Pyramid-B 帧，所以这些帧可以是 IDR/i/P/B 帧。如果设 IDR 帧则 GOP 收尾</li>
                        <li>根据 <code>--b-adapt</code> 指定的算法和 <code>--bframes</code> 的最大连续 B 帧长度，区分出 P 帧和 B 帧，得到如 PBBBPBP 的序列</li>
                        <li><code>--b-pyramid</code> 参数允许连续 B 帧中的偶数帧作为参考帧使用，保证了长距离的连续 B 帧</li>
                    </ul>
                </li>
                <li><b>维特比算法推演 P/B/b 帧</b>：
                    <button type="button" class="collapsible border-main rounded-3">点击展开/折叠内容：维特比算法的推演例子，可略</button>
                    <ul class="coll-content font-monospace pl-5 text-smaller">
                        <li>Viterbi shortest path 是一种多起点 - 多终点，类似于 A*和 Dijkstra 的最短路径算法。假设一种成本模型：
                            <ul>
                                <li>I 帧成本最高，记为设立成本 <span class="text-blue-math">\(cost_I=10\)</span>；I 帧后的非 I 帧成本 +1，记为转换成本 <span class="text-blue-math">\(cost_{IS}=1\)</span></li>
                                <li>P 帧成本次之，记为设立成本 <span class="text-blue-math">\(cost_P=5\)</span>；P 帧后的非 P 帧成本 +1，记为转换成本 <span class="text-blue-math">\(cost_{PS} = 1\)</span></li>
                                <li>B 帧成本最低，记为设立成本 <span class="text-blue-math">\(cost_B=2\)</span>；B 帧压缩最高，记为转换成本 <span class="text-blue-math">\(cost_{BS} = 0\)</span></li>
                                <li><code>--ref</code> 参数设定了参考帧的最远范围，使编码器不总选择成本最低的 B 帧</li>
                            </ul>
                        </li>
                        <li>应用到推演各帧的可能路径图：
                            <ul class="text-gray-side">
                                <li>Frame 0: I0, -, -（GOP 首帧只能是路径中的 I 帧）</li>
                                <li>Frame 1: I1, P1, B1</li>
                                <li>Frame 2: I2, P2, B2</li>
                                <li>Frame 3: I3, P3, B3</li>
                                <li>Frame 4: I4, P4, B4</li>
                                <li>...</li>
                            </ul>
                        </li>
                        <li>由此推演第 0，第 1 帧的成本，其中<span class="text-blue-math">\(cost(I_0)\)</span>代表第 0 帧为 I 帧的成本，<span class="text-blue-math">\(cost(I)\)</span>代表设立 I 帧的成本，则记为转换成本（当然此处严格一些应该直接写成 1）：
                            <ul class="text-gray-side">
                                <li>Frame 0: <span class="text-blue-math">\(10\)</span>, <span class="text-blue-math">\(\text{-}\)</span>, <span class="text-blue-math">\(\text{-}\)</span></li>
                                <li>Frame 1: <span class="text-blue-math">\(cost_{I0} + 10\)</span>, <span class="text-blue-math">\(cost_{P0} + cost_{IS} + 5\)</span>, <span class="text-blue-math">\(cost_{B0} + cost_{IS} + 2\)</span></li>
                                <li>Frame 1: 20, 16, 13，或 <span class="text-blue-math">\(cost_{I1} = 20\)</span>，<span class="text-blue-math">\(cost_{P1} = 16\)</span>，<span class="text-blue-math">\(cost_{B1} = 13\)</span></li>
                            </ul>
                        </li>
                        <li>正式采用维特比算法——选择每个帧的成本变为枝梢计算：设立成本 + 上帧三条路径中的最小值，推演第 2 帧及其后帧的成本：
                            <ul>
                                <li><span class="text-blue-math">\(I2 = min(cost_{I1} + 10, cost_{P1} + cost_{PS} + 10, cost_{B1} + 10) = min(20 + 10, 16 + 1 + 10, 13 + 10) = min(30,27,23) = 23\)</span></li>
                                <li><span class="text-blue-math">\(P2 = min(cost_{I1} + cost_{IS} + 5, cost_{P1} + 5, cost_{B1} + 5) = min(20 + 1 + 5, 16 + 5, 13 + 5) = min(26,21,18) = 18\)</span></li>
                                <li><span class="text-blue-math">\(B2 = min(cost_{I1} + cost_{IS} + 2, cost_{P1} + cost_{PS} + 2, cost_{B1} + 2) = min(20 + 1 + 2, 16 + 1 + 2, 13 + 2) = min(23,19,15) = 15\)</span></li>
                                <li class="text-gray-side">Frame 2: 23, 18, 15</li>
                                
                                <li><span class="text-blue-math">\(I3 = min(cost_{I2} + 10, cost_{P2} + cost_{PS} + 10, cost_{B2} + 10) = min(23 + 10, 18 + 1 + 10, 15 + 10) = min(33,29,25) = 25\)</span></li>
                                <li><span class="text-blue-math">\(P3 = min(cost_{I2} + cost_{IS} + 5, cost_{P2} + 5, cost_{B2} + 5) = min(23 + 1 + 5, 18 + 5, 15 + 5) = min(29,23,20) = 20\)</span></li>
                                <li><span class="text-blue-math">\(B3 = min(cost_{I2} + cost_{IS} + 2, cost_{P2} + cost_{PS} + 2, cost_{B2} + 2) = min(23 + 1 + 2, 18 + 1 + 2, 15 + 2) = min(26,21,17) = 17\)</span></li>
                                <li class="text-gray-side">Frame 3: 25, 20, 17</li>

                                <li><span class="text-blue-math">\(I4 = min(cost_{I3} + 10, cost_{P3} + cost_{PS} + 10, cost_{B3} + 10) = min(25 + 10, 20 + 1 + 10, 17 + 10) = min(35,31,27) = 27\)</span></li>
                                <li><span class="text-blue-math">\(P4 = min(cost_{I3} + cost_{IS} + 5, cost_{P3} + 5, cost_{B2} + 5) = min(25 + 1 + 5, 20 + 5, 17 + 5) = min(26,25,22) = 22\)</span></li>
                                <li><span class="text-blue-math">\(B4 = min(cost_{I3} + cost_{IS} + 2, cost_{P3} + cost_{PS} + 2, cost_{B2} + 2) = min(25 + 1 + 2, 20 + 1 + 2, 17 + 2) = min(28,23,19) = 19\)</span></li>
                                <li class="text-gray-side">Frame 3: 27, 22, 19</li>
                                <li class="text-gray-side">Frame 4: 29, 24, 21</li>
                            </ul>
                        </li>
                        <li>将复杂度（前后两帧画面差距）视作分母 <span class="text-blue-math">\(cplx_{0→1}\)</span>，将路径的值视作分子，就得到了该简化例子下的路径成本：
                            <ul class="text-gray-side">
                                    <li>Frame 0: I0, -, -（GOP 首帧只能是路径中的 I 帧）</li>
                                    <li>Frame 1: <span class="text-blue-math">\(\frac{cplx_{1→2}}{I1}\)</span>, <span class="text-blue-math">\(\frac{cplx_{0→1}}{P1}\)</span>, <span class="text-blue-math">\(\frac{cplx_{0→1}}{B1}\)</span></li>
                                    <li>Frame 2: <span class="text-blue-math">\(\frac{cplx_{2→3}}{I2}\)</span>, <span class="text-blue-math">\(\frac{cplx_{1→2}}{P2}\)</span>, <span class="text-blue-math">\(\frac{cplx_{1→2}}{B2}\)</span></li>
                                    <li>Frame 3: <span class="text-blue-math">\(\frac{cplx_{3→4}}{I3}\)</span>, <span class="text-blue-math">\(\frac{cplx_{2→3}}{P3}\)</span>, <span class="text-blue-math">\(\frac{cplx_{2→3}}{B3}\)</span></li>
                                    <li>Frame 4: <span class="text-blue-math">\(\frac{cplx_{4→5}}{I4}\)</span>, <span class="text-blue-math">\(\frac{cplx_{3→4}}{P4}\)</span>, <span class="text-blue-math">\(\frac{cplx_{3→4}}{B4}\)</span></li>
                                    <li>...</li>
                            </ul>
                        </li>
                        <li>如此一来，编码器就能得知什么时候设什么帧了</li>
                    </ul>
                </li>
                <li><b>宏块树搜索 MBTree</b>：
                    <ul class="font-monospace pl-5 text-smaller">
                        <li>分析时间空间范围内的块分布，找出少见的宏块，并计算出这些块的压缩强度偏移，以提高这些块的压缩</li>
                        <li>偏移程度的计算考虑了 Lookahead 中快速动态预测的准确度（当前和未来两帧相减，差距越大越复杂）</li>
                        <li>偏移程度的计算还考虑了当前帧与软转场 GOP 首帧的距离，距离越远越少见，分配的压缩强度越大</li>
                        <li>在这之前的软转场已将画面分界，所以“距离远”代表画面不变的情况下的距离远</li>
                    </ul>
                </li>
                <li><b>硬转场 keyint</b>：
                    <ul class="font-monospace pl-5 text-smaller">
                        <li>（等 mbtree 完成后）如果使用 <code>--no-open-gop</code>，且当前 GOP 长度达 <code>--min-keyint</code> 大小，则设立 IDR 帧以建立新的 GOP</li>
                        <li>IDR 帧（于 <code>--min-keyint</code> 范围内则设 I 帧）的前一帧会被强制改为 P 帧，以阻止 B 帧的双向参考特性</li>
                    </ul>
                </li>
                <li><b>量化值预设</b>：
                    <ul class="font-monospace pl-5 text-smaller">
                        <li>根据 <code>--rc-lookahead</code> 参数指定的长度为一组，通过当前和未来两帧相减，得到差值，以大致分配压缩强度</li>
                    </ul>
                </li>
                <li><b>VBV/VBR/CBR 码率限制</b>：见<a href="../../x265-web-tutorial/HTML/index.html#h2-11">x265 教程网页版：下层——VBR，CBR 模式</a></li>
            </ol>

            <code class="code-bold">--min-keyint</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数，默认 25，<span class="text-red-emph">小于等于 keyint</span>&gt;判断新发现的转场距离上个 IDR 帧是否小于该值长短。有两种设定逻辑，而它们给出的画质都一样：</p>
            <ul class="font-monospace pl-5 text-smaller">
                <li>一般通用，一定程度上防止硬转场干扰软转场的溯块参考冗余：<span class="text-blue-emph">keyint ÷2</span></li>
                <li>少设一些 IDR 帧，以略微提高压缩率和编码速度<span class="text-blue-emph">5 或更高</span></li>
                <li>快速编码/直播环境：<span class="text-blue-emph">等于 keyint</span></li>
                <li>多设一些 IDR 帧，一帧被判做转场本来就意味着前后溯块的价值不高。损失编码速度和压缩率，使复杂画面更接近素材视频级的图片序列，从而分配更多的码率 <span class="text-blue-emph">1 或 2</span></li>
            </ul>
            <code class="code-bold">--keyint</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数&gt;一般设 <span class="text-blue-emph">9 倍于帧率</span>（9 秒一个 IDR 帧），影响视频解码计算难度和拖进度条的延迟：</p>
            <ul class="font-monospace pl-5 text-smaller">
                <li>短视频，不拖进度条的视频：<span class="text-blue-emph">keyint -1</span>略微降低文件体积</li>
                <li>剪辑素材，频繁于多个视频轨上，根据画面复杂度设<span class="text-blue-emph">5 倍于帧率</span>，以降低解码负载</li>
            </ul>
            <code class="code-bold">--ref</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数 1~16&gt;多参考帧前后帧数半径，一图流设 <span class="text-blue-emph">1</span>。必须要在溯全尽可能多块的情况下降低参考长度，所以推荐 <span class="text-blue-emph">3</span>：</p>
            <code class="code-bold">--no-mixed-refs</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;开关&gt;关闭参考帧混合溯块（16×8，8×8 分块的参考）以提速，增加误参考。不推荐</p>
            <code class="code-bold">--scenecut</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数，不推荐用&gt;Lookahead 中两帧差距达到该参数值则触发转场</p>
            <code class="code-bold">--seek</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数，默认 0&gt;从第几帧开始压缩</p>
            <code class="code-bold">--frames</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数，默认全部&gt;一共压缩多少帧</p>
            <code class="code-bold">--fps</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数或除法&gt;设定输出视频帧率，只有源视频帧率错误才用得到。制动该参数后会自动开启 <code>-force-cfr</code></p>
            <code class="code-bold">--force-cfr</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;开关&gt;强制设定视频帧到整数时间码，可能用于对齐小数帧率的误差（如 23.976 或 24000/1001 变成 23.977）用</p>
            <code class="code-bold">--fullrange</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;开关，7mod x264 自动&gt;启用 0~255 色彩范围，而不是默认的 16~235。视频内容永远不在使用有限色域设备/软件/视频网站下播放下可以考虑开启</p>

            <h2 id="h2-5">动态预测 Motion Prediction</h2>
            <p>在参考帧（P-B 帧）的预测块 Prediction Block 上，动态搜索（ME）之前，起到<i>提供动态搜索起点</i>功能的预测算法。x264 使用了 <code>--direct</code> 指定。x265 中则使用了更高级的 AMVP + Merge 算法。</p>
            <p>视频里往往会有占据画面不小的物件朝着一处平移，在视频帧中表现为“某个区域的分块拥有高度相似的运动向量”。这些重复性的动态向量分布规律肉眼可见，而动态搜索只能通过不断地计算差异而一个一个方向和大小地把向量给试出来。这显然不如通过预测而快速地找出一组方向与大小（然后让整数像素动态搜索从这里开始微调到整数像素精度）直截了当。</p>
            <p>由于动态向量预测得到的向量本身就已经足够靠谱，因此编码器会以“预测动态向量（PMV）+ 动态向量差（MVD）”的形式记录每个帧间块的动态信息，再冗余掉相同的预测动态向量，从而进一步提高压缩。尽管一个动态向量的信息不多，但放眼到整个视频的所有帧间参考时，质变也就产生了。</p>
            <code class="code-bold">--direct</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;temporal/spatial/auto&gt; 指定动态搜索判断方式的参数，除直播和低性能设备录屏外建议 auto</p>

            <h2 id="h2-6">动态搜索 Motion Estimation（ME）</h2>
            <!-- x265 教程副本，更改需手动同步 { -->
            <p class="text-gray-side">注：它的专业术语是运动搜索、运动估计。</p>
            <p>在连续帧间画面中，进行运动估计的整数像素精度动态信息搜索步骤，涵盖了多种搜索算法，也被用于不同的信号处理领域。具体步骤是以被参考帧内的已编码块（Coded Block）为起点，尝试通过位移来匹配相邻帧的画面，从而找到一个失真最小的向量 Direction of minimal distortion（DMD），这个向量就是整数动态向量。</p>
            <p>为了找到可用的最小失真朝向，并且避免进行算力占用巨大的全搜索（Exhausive Search），动态搜索演化出了多种匹配的图案和算法。其中，较为聪明的动态搜索算法是多级算法，它们首会先尝试在较大范围进行粗略搜索，再以大致最佳区域为中心进行精细搜索，从而（包括在噪点干扰下）多快好省地找到整数动态向量。在整数动态搜索之后，还会由子像素动态搜索（Sub-pel Motion Estimation）来进一步做对齐，最终，这个动态向量被用于冗余预测块，以及对高动态画面提高有损压缩强度，从而压缩体积并优化码率的分配。</p>
            <p>如果动态搜索的过程有缺失或不够理想，参考帧与分块的建立会变得低效，码率分配也会变得不够合理，导致画质的降低和码率的增加。</p>
            <div class="align-items-center">
                <img src="files/memc/Interframe-Vector-Table.png" alt="Interframe-Vector-Table" class="img-medium">
                <p class="text-gray-side">图：宏块上帧间的动态向量</p>
            </div>
            <p>简化模型下，动态搜索得到帧间向量表，帧间向量表加上上帧的画面得到预测帧，原始帧减去预测帧得到残差帧，残差帧储存为参考帧，得到帧间结构。x264 使用了不对称多六边形搜索 Uneven multiple Hexagon，从而让一个搜索算法在多个分辨率下检查画面，制衡了动态噪点对传统动态搜索算法的干扰。搜索算法详见 <a href="../../x265-web-tutorial/HTML/index.html#h2-5">x265 教程</a>。</p>
            <!-- } -->
            <code class="code-bold">--me</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;hex/umh/esa/tesa，推荐 umh&gt; 搜索算法，umh 平衡，star 四角星搜索之后收益递减，sea 是优化过的 x264 esa 穷举，但收益递减仍大。umh 通过多种分辨率大小的查找范围，减轻了动态噪点对传统搜索算法的干扰</p>
            <code class="code-bold">--merange</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数，推荐 4 的倍数，<span class="text-red-emph">需 me</span>&gt;<span class="text-blue-emph">完全取决于 ME 算法和分辨率</span>，过大会因「找不到更好，找到也是错」而损失画质和压缩。</p>
            <ul class="font-monospace pl-5 text-smaller">
                <li>1920x1080 下推荐<span class="text-blue-emph">48</span>左右</li>
                <li>3840x2160 下推荐<span class="text-blue-emph">52</span>左右</li>
                <li>me hex 下设<span class="text-blue-emph">16</span></li>
                <li>me umh 设<span class="text-blue-emph">≥32</span></li>
            </ul>
            <code class="code-bold">--no-fast-pskip</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;开关，推荐开&gt; 关闭跳过编码 P 帧的功能</p>
            <code class="code-bold">--no-chroma-me</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;开关，推荐直播/录屏用&gt; 跳过色度平面动态搜索，将亮度平面直接应用。可能对画质有略微负面影响</p>
            <!-- x265 教程副本，更改需手动同步 { -->
            <h3>绝对变换差和 SATD</h3>
            <p>Sum of absolute transformed difference 为两个变换块间做差，取和，取绝对值的步骤：</p>
            <ol>
                <li>首先计算两个块 B 的插值，记做残差块 D：<span class="text-blue-math">\(\text{D}(x,y) = B(x,y) - B\prime(x,y)\)</span></li>
                <li>然后通过哈达码变换（相比 DCT 节约算力），得到变换残差块：<span class="text-blue-math">\(T(D)\)</span>
                    <ul><li>省略这一步，则算法叫做绝对差 Sum of absolute difference SAD</li></ul>
                </li>
                <li>最后，变换残差块的每个像素取绝对值和：<span class="text-blue-math">\(\text{SATD}(B,B\prime) = \sum_{x=0}^{n-1}{\sum_{y=0}^{n-1}}| T(D(x,y)) |\)</span></li>
            </ol>
            <p class="text-gray-side">注：为了简化所以写作 <span class="text-blue-math">\(T(D(x,y))\)</span>，实际这样相当于每加一个像素值就要变换一遍</p>

            <h2 id="h2-7">子像素运动补偿</h2>
            <p>全称 Subpixel refinement。动态预测的精度最高只有 1px，在此之上还有可能被动态噪点干扰，导致了预测帧相比原画会欠缺大量的纹理细节。动态补偿 Motion Compensation MC 通过对比原画与预测块得到残差，并根据残差的分布动态向量的精度到¼子像素，使“精加工预测块”的画面残差尽可能地缩小，得到足够准确的预测帧，即大幅减少残差帧的内容。</p>
            <div class="align-items-center">
                <img src="files/memc/Block-Spitting-Stage-Two.png" alt="Block-Spitting-Stage-Two" class="img-medium">
                <p class="text-gray-side">图：根据动态搜索与补偿所得，完成宏块到块的细分</p>
            </div>
            <p>至于对抗动态噪点，大体上是允许真正移动的物件（所涵盖的分块）有运动向量，拦截噪点在静止画面上的孤立运动向量，即「允动之移，防静所变」解决，详见 <a href="../../x265-web-tutorial/HTML/index.html#h2-6">x265 教程</a>。</p>
            <ol class="overflow-auto">
                <li>此处省略<span class="text-blue-math">上帧画面 + 帧间向量表中的动态向量 = 一系列粗加工预测块</span>的步骤</li>
                <li>使用有限冲激响应插值滤镜 FIR filter 放大画面以便后面对齐</li>
                <li>将“粗加工预测块”与源视频所对应的画面使用 SATD 做差，得到当前的误差程度</li>
                <li>当前向量的 x，y 分量分别加减 ½，¼ 像素（插值放大的画面中是整数像素），即分别让这些块对比原画跑一遍 SATD：
                    <ul class="text-smaller">
                        <li><span class="text-blue-math">\(B\prime(x+½,y),B\prime(x,y+½),B\prime(x+½,y+½),B\prime(x+¼,y),B\prime(x,y+¼),B\prime(x+¼,y+¼),B\prime(x+¼,y+½),B\prime(x+½,y+¼)\)</span></li>
                    </ul>
                </li>
                <li>选出 SATD 误差值最小的块——中的 x,y 分量，纠正帧间向量表的动态矢量，完成补偿</li>
            </ol>
            <!-- } -->
            <p>关于 FIR 插值滤镜，以及 x264/5 分别使用了哪些插值和搜索方法，见<a href="../../x265-web-tutorial/HTML/index.html#h2-6">x265 教程网页版 - 动态补偿</a>。</p>

            <code class="code-bold">--subme</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数 1~10，推荐 6~10&gt;调整具体的动态补偿强度，x264 中同时决定模式决策和率失真优化的强度。根据画质和编码速度选择合适的大小：</p>
            <ul class="font-monospace pl-5 text-smaller">
                <li><span class="text-blue-emph">1</span> 逐块 1/4 像素使用 SAD 算法检验一种对齐</li>
                <li><span class="text-blue-emph">2</span> 逐块 1/4 像素 SATD 算法检验两种对齐</li>
                <li><span class="text-blue-emph">3</span> 逐宏块 1/2 像素 SATD 一次，逐块 1/4 像素 SATD 一次</li>
                <li><span class="text-blue-emph">4</span> 逐宏块 1/4 像素 SATD 一次，逐块 1/4 像素 SATD 一次</li>
                <li><span class="text-blue-emph">5</span> 同时增加双向参考 B 块</li>
                <li><span class="text-blue-emph">6</span> 同时 I，P 帧启用率失真优化处理</li>
                <li><span class="text-blue-emph">7</span> 同时 I，P，B，b 帧启用率失真优化处理 </li>
                <li><span class="text-blue-emph">8</span> 同时 I，P 帧启用 <code class="code-bold">rd-refine</code> 功能</li>
                <li><span class="text-blue-emph">9</span> 同时 I，P，B，b 帧启用 <code class="code-bold">rd-refine</code> 功能</li>
                <li><span class="text-blue-emph">10</span> 使用 <code>--me hex</code> 动态搜索检验对齐，<span class="text-red-emph">需 <code>--trellis 2 --aq-strength &gt; 0</code></span></li>
                <li><span class="text-blue-emph">11</span> 关闭所有提前退出，边际效应过大，不推荐使用</li>
            </ul>
            <code class="code-bold">rd-refine</code>（内部参数）
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;嵌入 <code>--subme 8</code> 中，x265 中可手动打开&gt; 率失真优化分析帧内预测的最佳量化和分块结果，耗时换压缩率和画质。x264 中还包括了最优动态向量的分析</p>

            <h3>细分块</h3>
            <code class="code-bold">--partitions</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;字符串 <code>p8x8</code>，<code>p4x4</code>，<code>b8x8</code>，<code>i8x8</code>，<code>i4x4/none/all</code>，默认 <code>p8x8</code>，<code>b8x8</code>，<code>i8x8</code>，<code>i4x4</code>，推荐 <code>all</code>&gt;允许的细分块种类。增加分块种类会增加计算负载，但 x264 放到现在来看，也只有高分辨率快速编码场景才需要保持默认。因此推荐 <span class="text-blue-emph">all</span></p>
            <ul class="font-monospace pl-5 text-smaller">
                <li>开启 <span class="text-blue-emph">p8x8</span> 会同时启用 p16x8，p8x16</li>
                <li>开启 <span class="text-blue-emph">p4x4</span> 会同时启用 p8x4，p4x8</li>
                <li>开启 <span class="text-blue-emph">b8x8</span> 会同时启用 b16x8，b8x16</li>
                <li>因为 <a href="https://forum.doom9.org/showthread.php?t=125734">边际效益太小</a>，x264 开发者取消了 b4x4 分块</li>
            </ul>

            <h2 id="h2-8">变换</h2>
            <div class="row">
                <p id="LR-UD-003" class="col-10">模拟信号转换为数字信号的主要步骤之一——将音量、亮度、温度、压力等信号整理为低频到高频的单一信号/波形分量。具体来说，这个过程根据要处理的信号和用途不同，会使用傅里叶变换，小波变换，和 x264/5 使用的二维离散余弦变换 2D Discrete cosine transform。二维离散余弦变换利用预制的二维波形模具，通过穷举加减将源信号逐步分解成不同频率的平面波形，并合成变换块。<span class="text-gray-side">图：缩放到 8x8 的波形分布，由于 cos(x) 的波形范围是 -1~1，所以图中的黑色到白色并不是 0~255 或 16~235，而是 -1~1</span> </p>
                <img src="files/transform-quantization/DCT-Block.png" alt="DCT-Block" id="LR-UD-004" class="img-small img-right col-2 mb-auto">
            </div>
            <p>变换的过程中，“DCT 像素”称为系子 coefficients。这些系子的强度可以是负值，表示反相的波形；也可以是小数，表示低强度的波形（但因为计算机浮点计算慢于整数计算，所以一般仅用于演示）。变换块左上角的系数是直流 DC 分量，代表整体亮度水平，其余的系数是交流 AC 分量，表示图像中的细节和纹理信息。</p>

            <h3>量化</h3>
            <p>根据压缩强度给出一个除数或矩阵数组，将变换结果的每个值除以这个除数或矩阵中同位的值，只保留和使用商来解码播放，从而实现压缩。这步操作是压缩中画面损失最大的步骤。</p>
            <h4>量化值 Quantization Parameter</h4>
            <p>QP 是 CRF，ABR 等码率质量控制模式算出，以及率失真优化量化、模式决策等步骤所调整的中间变量</p>
            <h4>量化步长 <span class="text-blue-math">\(Q_{\text{step}}\)</span></h4>
            <p>Quantization Step-size 是量化值量化强度参数值与实际量化强度之间的映射值。规则大致是量化强度增加 1，则 qStep 增加 0.125；QP 每 +6 则 qStep 乘以 2，使其越往后增量越大：</p>
            <div class="overflow-auto">
                <table class="table-center align-items-center text-smaller">
                    <tbody>
                        <tr class="border-lr">
                            <th class="t-light-gray">QP</th>
                            <td class="px-1"><b>0</b></td>
                            <td class="px-1"><b>1</b></td>
                            <td class="px-1"><b>2</b></td>
                            <td class="px-1"><b>3</b></td>
                            <td class="px-1"><b>4</b></td>
                            <td class="px-1"><b>5</b></td>
                            <td class="px-1"><b>6</b></td>
                            <td class="px-1"><b>7</b></td>
                            <td class="px-1"><b>8</b></td>
                            <td class="px-1"><b>9</b></td>
                            <td class="px-1"><b>10</b></td>
                            <td class="px-1"><b>12</b></td>
                            <td class="px-1"><b>14</b></td>
                            <td class="px-1"><b>16</b></td>
                            <td class="px-1"><b>18</b></td>
                            <td class="px-1"><b>20</b></td>
                            <td class="px-1"><b>22</b></td>
                            <td class="px-1"><b>24</b></td>
                            <td class="px-1"><b>26</b></td>
                            <td class="px-1"><b>28</b></td>
                            <td class="px-1"><b>30</b></td>
                            <td class="px-1"><b>32</b></td>
                            <td class="px-1"><b>34</b></td>
                            <td class="px-1"><b>36</b></td>
                            <td class="px-1"><b>38</b></td>
                            <td class="px-1"><b>40</b>…</td>
                        </tr>
                        <tr class="border-lr">
                            <th class="t-light-gray"><span class="text-blue-math">\(Q_{\text{step}}\)</span></th>
                            <td class="px-1">0.625</td>
                            <td class="px-1">0.6875</td>
                            <td class="px-1">0.8125</td>
                            <td class="px-1">0.875</td>
                            <td class="px-1">1</td>
                            <td class="px-1">1.125</td>
                            <td class="px-1">1.25</td>
                            <td class="px-1">1.375</td>
                            <td class="px-1">1.625</td>
                            <td class="px-1">1.75</td>
                            <td class="px-1">2</td>
                            <td class="px-1">2.5</td>
                            <td class="px-1">3.25</td>
                            <td class="px-1">4</td>
                            <td class="px-1">5</td>
                            <td class="px-1">6.5</td>
                            <td class="px-1">8</td>
                            <td class="px-1">10</td>
                            <td class="px-1">13</td>
                            <td class="px-1">16</td>
                            <td class="px-1">20</td>
                            <td class="px-1">26</td>
                            <td class="px-1">32</td>
                            <td class="px-1">40</td>
                            <td class="px-1">52</td>
                            <td class="px-1">64…</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>x264 中，量化值大致上存在于以下几处：</p>
            <div class="overflow-auto">
                <table class="table-center">
                    <thead>
                        <tr>
                            <th class="px-1">步骤</th>
                            <th class="px-1">名称</th>
                            <th class="px-1">应用</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr class="border-bottom t-light-gray">
                            <td class="px-1">率控制</td>
                            <td class="px-1">CRF/ABR</td>
                            <td class="px-1">逐帧量化强度（或全局量化强度）</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-1">I-P 帧质量比</td>
                            <td class="px-1">I-P Ratio</td>
                            <td class="px-1">P 帧量化强度</td>
                        </tr>
                        <tr class="border-bottom t-light-gray">
                            <td class="px-1">P-B 帧质量比</td>
                            <td class="px-1">P-B Ratio</td>
                            <td class="px-1">B 帧量化强度</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-1">自适应量化</td>
                            <td class="px-1">Adaptive Quantzation AQ</td>
                            <td class="px-1">逐块量化强度</td>
                        </tr>
                        <tr class="border-bottom t-light-gray">
                            <td class="px-1">（率失真优化）模式决策</td>
                            <td class="px-1">Mode Decision MD</td>
                            <td class="px-1">逐块量化强度</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-1">率失真优化量化</td>
                            <td class="px-1">Rate-distortion optimized quantization RDOQ</td>
                            <td class="px-1">逐块量化强度</td>
                        </tr>
                        <tr class="t-light-gray">
                            <td class="px-1">色度块量化强度偏移</td>
                            <td class="px-1"><code>--chroma-qp-offset</code></td>
                            <td class="px-1">亮度与色度块量化强度</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h2 id="h2-9">率控制</h2>

            <h3>码率分布成因</h3>
            <p>有损压缩中，只是优化码率分配本身就可以提高当前视频的画质。这是因为参考帧 P、B 帧自身的主要信息来自于被参考帧 I 帧，其中被冗余的宏块只储存“相对于被参考帧的动态向量”，和“残差画面”。这种画面并不锐利，因而（在熵编码后的）体积占比非常小。而尽管被参考帧 I 帧的体积很大，但 I 帧自身的画面为其后的若干至数百帧提供了参考，使得高画质的 I 帧反而提高了帧间冗余压缩率（与使用 10bit 位深后，码率不增反降的原因相同）。假如被参考帧 I 帧的有损压缩较高，那么在环路滤镜组/率失真优化过程中，编码器会发现 I 帧与 P、B 帧之间不太相像；便会提高残差画面的信息量。于是虽然峰值码率会降低，但 I 帧后的一系列帧都会比以往大一些，造成整体的码率/文件体积上升。在这个基础上：</p>
            <ul>
                <li>如果视频本身的画面变化偏大，那么参考帧 P、B 帧一开始就会储存更多的残差信息</li>
                <li>如果一开始就要求限制峰值码率，那么即使文件体积增加，码率提高也是没办法的事</li>
                <li>如果一开始就要求固定文件体积大小（不超过某个程度），那么原本的“码率提高”就会完全变成“画质降低”</li>
            </ul>
            <div class="align-items-center">
                <img src="files/rate-control/hyouka-frame-distro.webp" alt="hyouka-frame-distro" class="">
                <p class="text-gray-side">图：这段 1920x1080 视频约有 36000 帧，其中 I 帧占 1%。从趋势线可以看出平均每帧的大小位于 200Kb 以下（很多都在 10b 以下）。2000Kb 以上的帧零散存在，中心还有一张 9544 Kb（1.2MB）的帧。</p>
                <img src="files/rate-control/solevante-frame-distro.webp" alt="solevante-frame-distro" class="">
                <p class="text-gray-side">图：这段场景动态复杂的 3840x2160 视频约有 6000 帧，除了 I 帧的尖峰以外，出现了整块隆起的码率分布，左侧的复杂部分达到了 6~10Mbps。</p>
            </div>

            <h3>压制三角形</h3>
            <p>一般情况下，用户希望在可接受的编码速度（fps 为单位）下，得到画质较高、文件体积较小的视频，构成了压制三角形。要求速度和文件体积则失画质、要求文件体积和画质则损速度、要求速度和画质则损文件体积。</p>
            <div class="align-items-center">
                <img src="files/basics/Encoding-Trade-off-Triangle.png" alt="Encoding-Trade-off-Triangle" class="img-medium">
                <p class="text-gray-side mt-0">图：三种出发点构成。其“完美中心点”不一定符合当下需求，但决定了是否能满足所有情况</p>
                <img src="files/rate-control/rate-control-mode-selection.png" alt="rate-control-mode-selection" class="img-medium">
                <p class="text-gray-side">图：不同率控制模式权衡编码速度，画质，文件体积的能力不同，当然有的模式根本没得选</p>
            </div>

            <h3>两个一致、三边取点</h3>
            <p>“码率分布成因”中说明了在画质高度一致时，逐帧的码率变化非常大，在网络播放时可能会因为峰值而卡顿；反过来倘若要限制码率变化/波动，则画质的一致性便会下降（或文件体积增加）。于是在选择率控制模式时，要在“两个一致”之间妥协。</p>
            <p>“压制三角形”中说明了在速度、画质和文件体积三者此消彼长，虽然大多情况下选择兼顾三者的中心点即可，但也需要根据不同场景的要求加以偏置</p>

            <h3>率控制模式</h3>
            <h4>平均码率模式 Average Bitrate</h4>
            <ul>
                <li>设定统一的“平均每帧大小”（以码率每秒 / Kbps 统计）</li>
                <li>编码器会根据目标平均码率和剩余帧数，粗略估算每帧可用的码率预算，只要这个平均值不超过用户设定的平均码率，就按照现有逻辑（MEMC、帧类型、块大小）设定每帧的量化强度</li>
                <li>P、B 帧由于运动矢量等信息依赖其他帧，通常量化强度可以更高，体积更小</li>
                <li>I 帧则要独立编码，体积较大，如码率紧张，I 帧可能需要更强量化（画质下降更明显）</li>
            </ul>
            <h5>ABR 模式优缺点</h5>
            <ul class="text-smaller">
                <li>思路简单快速</li>
                <li>适合直播场景</li>
                <li>编码器编码 GOP 前半部分时照此操作无妨，但到了后面，若画面突然开始变化，那么当前码率会立刻上升到设定的平均码率上限，此时只能分配更强的量化强度的“码率分配不匀问题”</li>
                <li>如果用户设定的码率太低，ABR 模式会设立强量化</li>
                <li>如果强量化不够还会启用一些滤镜，导致画面损失太严重，无法辨认内容</li>
                <li>如果用户设定的码率大于等于如 CRF、2pass 模式，则仍可能遇到“码率分配不匀问题”</li>
            </ul>
            <h4>全局/固定量化强度模式 Constant Quantizer</h4>
            <ul>
                <li>跳过量化强度自适应算法，直接由用户指定 I、P、B（等）帧各自的量化强度</li>
            </ul>
            <h5>CQP 模式优缺点</h5>
            <ul class="text-smaller">
                <li>速度最快</li>
                <li>可以通过设定最小量化值的方法跳过量化，实现一种无损压缩模式</li>
                <li>码率分配不匀问题最严重，码率与文件体积体积不易预测</li>
            </ul>
            <h4>质量呼应码率模式 Constant Rate Factor</h4>
            <ul>
                <li>在设定量化强度指标（CRF 参数值）的基础上，允许编码器根据当前画面的特性与帧类型进一步优化每帧的量化强度分配</li>
                <li>若 CRF 值较低，而当前帧可以使用较高的量化压缩强度（如参考帧 P、B 帧）时，编码器会提高量化强度；这样不但文件体积缩小，损失的画质也肉眼难辨</li>
                <li>CRF 值越大，最终画质越差、码率越低；这样码率的分配仍然会是均匀的极优解</li>
            </ul>
            <h5>CRF 模式优缺点</h5>
            <ul class="text-smaller">
                <li>同码率下的压缩率、画质最好，最适合用于分享和收藏高质量小体积视频素材</li>
                <li>在要求实时编码的场景中可能会因为编码 I 帧考虑太多、用时过长、导致延迟丢帧</li>
                <li>调整 CRF 和 CQP 模式不能直接控制文件体积，尽管这是因为“视频在这个质量下，只能压缩到这个程度”，但有时会导致用户不理解</li>
                <li>在严格要求视频体积的场景中，如微信等平台会因为文件体积限制而不便于分享
                    <ul><li>尽管这种情况下应该用技术更先进的编码器，但因为用户、平台、手机厂商的多方因素，所以导致了视频打不开的兼容性问题</li></ul>
                </li>
            </ul>
            <h4>恒定码率模式 Constant Bitrate（CBR）、可变码率模式 Variable Bitrate（VBR）</h4>
            <ul>
                <li>在 ABR 或 CRF 模式的基础上启用码率缓冲区（Video Buffer Verifier、VBV）控制得到</li>
                <li>CRF 模式本质上属于半个 VBR 模式，ABR 模式本质上属于半个 CBR 模式；两者都依赖 VBV 限制码率峰值</li>
                <li>当码率超过用户指定的 VBV 上限，则编码器自动增大量化强度，以防溢出</li>
                <li>I 帧后的一系列帧都会比以往大一些，造成整体的码率/文件体积上升，峰值下降</li>
                <li>如果整体码率上升触发 ABR 限制，则进一步增加量化强度，画质下降，换来带宽控制，得到变化更平稳的码率分布</li>
            </ul>
            <h5>CBR、VBR 模式优缺点</h5>
            <ul class="text-smaller">
                <li>可以解决峰值码率过大的问题</li>
                <li>代价是整体文件体积提升（VBR），或者整体画质下降（CBR）</li>
                <li>使得 CRF、ABR 模式能够更好地胜任直播、串流（外网网络播放）场景</li>
            </ul>
            <h4>两遍模式 2pass</h4>
            <ul>
                <li>Pass 1：运行 CRF 或 ABR 模式，得出每帧的量化强度，从而得出码率分配统计</li>
                <li>Pass 2：运行 ABR 模式，利用第一遍采集的码率分布，事先完成所有帧的码率预分配，从而精准控制文件体积</li>
                <li>尽管不同的编码器对 2pass 模式的实现有差异，但基本流程与此处一致</li>
            </ul>
            <h5>2pass 模式优缺点</h5>
            <ul class="text-smaller">
                <li>解决了 ABR 模式在 GOP 前后码率分配不匀的问题</li>
                <li>码率分配不匀的问题被弱化，只要最终码率类似，2pass 就能做到相当于 CRF 同码率的均匀度</li>
                <li>能够精准控制文件体积（目标体积 ÷ 视频时长 = 目标码率），适用于硬性要求视频体积，还要考虑编码兼容性的场景
                    <ul><li>例如，一个聊天平台限制上传文件不可以超过 200MB，就是一种硬性体积要求</li></ul>
                </li>
                <li>Pass 2 与 Pass 1 的帧类型分布（绝大多情况下）必须完全一致，所以如转场、关键帧、前瞻进程等设置需要更改时只能重做 Pass 1</li>
                <li>如果要使用高压缩，则必须在 Pass 1 就使用速度较慢动态搜索与补偿，从而使得整个流程下来的编码用时远超其他模式</li>
                <li>流程复杂，故障点（Point of failure）最多，操作相对困难</li>
            </ul>

            <h3>常见的误解误区</h3>
            <ol>
                <li>“我有硬性视频体积要求。我要求在保证一定视频质量的同时，将体积缩的小一点，所以应该使用 2pass 模式”
                    <ul class="text-smaller">
                        <li>硬性不是弹性，如网站对文件体积的大小上限“不得超过 200 MB”才是硬性需求</li>
                        <li>“保证一定视频质量的同时，将体积缩的小一点”是 CRF 模式所针对的需求</li>
                    </ul>
                </li>
                <li>“我希望控制体积和码率，画质差一些可以，但不能一会清晰一会模糊，所以应该使用 CBR 模式”
                    <ul class="text-smaller">
                        <li>CBR 模式保证的是码率变化的一致性，在上面的例子中已经展示了画质高度一致时的码率变化</li>
                        <li>CRF 模式有“CRF 值”来保证画质的一致性，应该使用 CRF 模式</li>
                    </ul>
                </li>
                <li>“我的视频要上传到视频平台，上面说达到多少平均码率后可以免二压，所以应该使用 2pass 模式”
                    <ul class="text-smaller">
                        <li>所谓的免二压规则早已绝迹，视频平台一律压缩上传的视频，除非是个人搭建的网站</li>
                    </ul>
                </li>
            </ol>
            

            <code class="code-bold">--ipratio --pbratio</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;浮点，默认 1.4、默认 1.3&gt;P 帧相比 IDR/i 帧，以及 B/b 帧相比 P 帧的质量偏移。默认预设是给录像视频片源用的。</p>
            <ul class="font-monospace pl-5 text-smaller">
                <li>低成本动漫/多静态画面/PPT 录屏画面：<span class="text-blue-emph">各降低 0.2</span></li>
                <li>剪辑素材：<span class="text-blue-emph">提高 --crf，不用改这两个参数</span></li>
                <li>YCbCr 4:4:4 片源：<span class="text-blue-emph">x264 默认会自动修改 --chroma-qp-offset，不用改这两个参数</span></li>
            </ul>

            <h4>CRF 模式</h4>
            <p>质量呼应码率模式，统称 CRF。压制三角形下距离妥协中心点最近的模式。因此也是压制最常用的模式。编码器逐帧分析量化强度，为每帧分配一个量化值。</p>
            <code class="code-bold">--crf</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;浮点范围 0~51，默认 23&gt;据 cplxBlur，cutree，B 帧偏移给每帧分配各自量化强度的固定目标质量模式。素材级画质设在 16~18，收藏~高压画质设在 19~20.5，YouTube 是 23</p>
            
            <h4>ABR 模式</h4>
            <p>编码器自行判断量化程度，尝试压缩到用户定义的平均码率 average bitrate 上，速度最快</p>
            <code class="code-bold">--bitrate</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数 kbps&gt;平均码率。若视频易压缩且码率给高，就会得到码率比设定的片子；反过来低了会不照顾画质强行提高量化，使码率达标。一般推流用的“码率选项”就是设置了这个参数</p>

            <h4>CQP 模式</h4>
            <code class="code-bold">--qp</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数 0~69，<span class="text-red-emph">禁用 CRF/ABR/模式决策/率失真优化</span>&gt;设定全局量化强度。除非有既定目的，否则不建议使用。如果要手动指定特定范围的帧类型和量化值，则应使用 SBRC 下层模式</p>

            <h4>Zones 分段模式</h4>
            <button type="button" class="collapsible border-main rounded-3">点击展开/折叠内容</button>
            <div class="coll-content">
                <p>手动指定帧数片段，每个片段允许指定一种上层模式和一些控制参数。</p>
                <code class="code-bold">--zones</code>
                <p class="font-monospace pl-5 m-0 overflow-auto">&lt;开始帧，结束帧，参数 A，参数 B…&gt; 手动在视频中划区，采用不同上层模式来实现如提高压制速度，节省平均码率，提高特定画面码率等用途 (一般用来"处理"片尾滚动字幕). zones 内的 me, merange 强度/大小不能超 zones 外。可用参数有 b=, q=, crf=, ref=, scenecut=, deblock=, psy-rd=, deadzone-intra=, deadzone-inter=, direct=, me=, merange=, subme=, trellis=</p>
                <ol class="font-monospace pl-5 text-smaller">
                    <li>参数 b= 调整码率比率，限制 <code>--zones</code> 内的场景使用当前 0~99999% 的码率，100% 相当于不变</li>
                    <li>参数 q= 即 CQP 模式的 <code>--qp</code> 参数</li>
                </ol>
            </div>

            <h3>2pass 模式</h3>
            <p>先用 CRF 模式分析整个视频总结可压缩信息，后根据 ABR 模式的码率限制统一分配量化值。有 pass 2 给特别高的平均码率，输出最小损失的最小体积近无损模式，以及 pass2 给码率硬限的全局整体压缩模式</p>
            <code class="code-bold">--pass 1</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;挡位，导出 stats 数据文件&gt;</p>
            <code class="code-bold">--pass 2</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;挡位，导入 stats 数据文件&gt;</p>
            <code class="code-bold">--stats</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;路径，默认在 x264/5 所在目录下&gt;设定导出和导入 stats 数据文件的路径和文件名</p>

            <h3>VBR，CBR 模式</h3>
            <p>带宽是有限资源。一旦网络、硬盘、内存、PCIE 等等带宽慢于当前视频码率，播放就会卡顿。因此在播放流媒体前，播放器会设置一段内存缓冲区，利用了传输速度有时会快于当前视频码率的随机条件，预加载一些数据以求播放不卡顿。此时问题变成了“缸里一端加水、另一端放水，注水量变化但缸里一直有水，求缸的大小”。如此，只要平均传输带宽大于 GOP 平均码率则播放流畅。有的大型 3D 游戏中没有加载缓冲区，导致无论电脑内存多大，只要玩家移动到触发地图加载的区域后，游戏才会开始读盘而突然卡顿。</p>
            <p>基于缓冲区的量化控制 VBV 全称 Video Buffer Verifier：</p>
            <ol>
                <li>保证 <code>rc-lookahead</code> 范围内，用户通过 <code>vbv-bufsize vbv-maxrate</code> 指定网络/设备元器件带宽所能及的缓冲速度是否大于等于码率流量</li>
                <li>码率超过缓冲区域则视频必然会卡顿，所以加大视频中「码率大于带宽处」的压缩强度。因此 VBV 对画质的破坏较大</li>
                <li>与 CRF 上层模式一并使用时叫可变码率 Variable BitRate（VBR），或 Capped-CRF 模式</li>
                <li>与 ABR 上层模式一并使用时叫固定码率 Constant BitRate（CBR），或 Capped-ABR 模式</li>
            </ol>
            <code class="code-bold">--vbv-bufsize</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数 kbps，默认关=0，<span class="text-red-emph">小于 maxrate</span>&gt;编码器解出原画后，最多可占的缓存每秒。bufsize÷maxrate=播放时解码出每 gop 原画帧数的缓冲用时（秒）。<span class="text-blue-emph">值的大小相对于编完 GOP 平均大小。编码器用到是因为模式决策要解码出每个压缩步骤中的内容与原画作对比用</span>。</p>
            <code class="code-bold">--vbv-maxrate</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数 kbps，默认关 0&gt;峰值红线。用「出缓帧码率 - 入缓帧码率必须小于等于 maxrate"」限制编码器在 GOP 码率超 bufsize，即缓存跑满时压缩超载帧（提高量化强度 + 强降噪至码率合规为止）。当入缓帧较小时，出缓帧就算超 maxrate 也会因缓存有空而不被压缩。所以有四种状态，需经验判断：</p>
            <ul class="font-monospace pl-5 text-smaller">
                <li>大：GOP 大小=bufsize=2×maxrate，视频码率超出 maxrate 后等缓存满再压缩，避开多数涨落，适合限平均率的串流</li>
                <li>小：GOP 大小=bufsize=1×maxrate，视频码率超出 maxrate 后直接压缩，避开部分涨落，适合限峰值的串流</li>
                <li>超：GOP 大小&lt;bufsize=1~2×maxrate，视频码率超出 maxrate 后直接压缩，但因视频小/crf 大所以作用不大</li>
                <li>欠：GOP 大小&gt;bufsize=1~2×maxrate，视频码率超出 maxrate 后直接压缩，但因视频大/crf 小所以全都糊掉</li>
            </ul>
            <p class="font-monospace pl-5 m-0 overflow-auto">由于 gop 多样，4 种状态可以出现在同一视频中。buf/max 实际控制了这些状态的出现概率</p>
            <!-- } -->
            <code class="code-bold">--nal-hrd</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;开关，默认关，<span class="text-red-emph">需 VBV</span>&gt;开启假想对照解码器 Hypothetical reference decoder。与假想播放流程中得到额外的 VBV 控制信息，并写进每段序列参数集 sps 及辅助优化信息 sei 里，适合提高 VBV 控制精度</p>
            <code class="code-bold">--ratetol</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;浮点百分比，默认 1&gt; maxrate 限码的容错程度，用于防止压缩过大，但与此同时码率过大所导致卡顿的次数会增加</p>

            <!-- x265 教程副本，更改需手动同步 { -->
            <h3>下层 - FTQP 模式</h3>
            <p>手动通过文件制定帧类型和量化强度。</p>
            <code class="code-bold">--qpfile</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;路径到文件&gt;手动指定帧类型和量化强度 closed-gop 下 K 帧的 frame type量化强度下层模式。qpfile 文件内的格式为"帧号 帧类型 QP"</p>
            <ul class="font-monospace pl-5 text-smaller">
                <li>帧类型可以选 [I,i,K,P,B,b]</li>
                <li>大写 B 代表 B-Pyramid</li>
                <li>大写 I 代表 IDR 帧</li>
                <li>K 在 <code>--no-open-gop</code> 时代表 IDR 帧</li>
                <li>K 在  <code>--open-gop</code> 时代表 i 帧</li>
                <li>x265 中，量化强度（QP 值）可以不填，代表使用上层率控制模式</li>
                <li>x264 中，量化强度（QP 值）填<span class="text-blue-emph">-1</span> 代表使用上层率控制模式</li>
            </ul>
            <p class="font-monospace pl-5 m-0 overflow-auto">qpfile.txt 例：</p>
            <ul class="font-monospace pl-5 text-smaller list-dotless">
                <li>0 I 18</li>
                <li>1 P 20</li>
                <li>2 B 22</li>
                <li>3 i 21</li>
                <li>4 b 28</li>
            </ul>
            
            <h3>其它率控制</h3>
            <p>可以搭配除 CQP 以外的上下层模式使用，决定了视频各处的最终量化值</p>
            <code class="code-bold">--qpmin</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数 0~51&gt;由于画质和优质参考帧呈正比，所以仅高压环境建议设最高 14</p>
            <code class="code-bold">--qpmax</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数 0~51&gt;在要用到颜色键，颜色替换等需要清晰物件边缘的滤镜时，可以设<span class="text-blue-emph">26</span>防止录屏时物件的边缘被压缩的太厉害，其他情况永远不如关 <code>--cutree/--mbtree</code></p>
            <!-- } -->
            <!-- 额外参数（与 x265 教程不同）：-->
            <code class="code-bold">--chroma-qp-offset</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数，默认 0&gt;AVC 规定 CbCr 的码率之和应等于 Y 平面，所以 x264 会拉高色度平面的量化。</p>
            <ul class="font-monospace pl-5 text-smaller">
                <li>使用 <code>--psy-rd</code> 后，x264 会自动设定 <span class="text-blue-emph">-2~-4</span>。</li>
                <li>不用 <code>--psy-rd</code> 时，动漫或幻灯片录屏片源的 4:2:0 视频可手动设 <span class="text-blue-emph">-2~-4</span></li>
                <li>编码 YCbCr 4:4:4 时，x264 会自动设定 <span class="text-blue-emph">-2~-4</span>。</li>
            </ul>
            <!-- 额外参数（与 x265 教程不同）：-->
            <code class="code-bold">--slow-firstpass</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;开关&gt;pass1 里自动关闭以下提速，或自动提高以下参数的强度，以保证 pass1 模式中 CRF 模式计算量化值的准确度：<code>no-8x8dct me dia partitions none ref 1 subme &lt;=2 trellis 0 fast-pskip</code>，可手动覆盖为强度更高的参数</p>

            <h2 id="h2-10">自适应量化</h2>
            <p>一种利用感知对比度掩蔽现象的帧内分块码率重分配方法。</p>

            <h3>感知对比度掩蔽现象 Perceptual contrast masking</h3>
            <p>类似于亮度与响度掩蔽。空间频率高，纹理复杂的画面能够掩蔽频率低，纹理简单的画面内容，如自然界中的动物通过“打乱”自身外形的线条和纹理细节，从而在不改变颜色，体温和体型大小的情况下实现的可见光伪装。这种效应的参数包括：</p>
            <ul>
                <li>空间距离差异——两种特征的距离越近，掩蔽越强</li>
                <li>特征差异——两种特征的摆放角度，空间频率越接近，掩蔽越强</li>
                <li>对比度差异——两种特征的对比度越大，掩蔽越强</li>
            </ul>
            <p>这种现象代表了量化失真可以被图像中的纹理所掩蔽的规律，因此纹理越复杂且对比度越高，人眼就越难以察觉到量化失真（尤其是动态纹理，如海面的变化）。自适应量化通过逐分块地微调量化强度，从而实现这种基于感知的量化 Perceptual based quantization 更合理地分配码率。</p>
            <p>简单地说，只要量化失真处的像素值变化程度不大于纹理像素值变化的程度即可。这种方法虽然常用在视频编码中，但对比度感知现象的原理尚不明确——如果观众仔细看就会发现失真。</p>

            <h3>方差 Variance</h3>
            <p>方差表示数据样本相对于整体平均值的离散程度，通过差→方→和→均的计算顺序，以偏差之和窥数据之衡。这里的偏差就是上述的像素值对比度，通过“和→均”的平均法来均摊偏差程度，防止少数较大的偏差影响整体；而“差→方”平衡了前者对结果值的缩小，另一方面对高差距处加权，以影响判断结果不倾向于完全平均，从而更符合数据的实际变化情况。计算如下：</p>
            <span class="text-blue-math">\[ \sigma^{2}=\frac{\sum_{i=1}^{N} (x_{i}-\overline{x})^{2}}{N} \]</span>
            <ol class="font-monospace pl-5 text-smaller">
                <li>每个数据样本减去整体平均值，得到差值</li>
                <li>差值进行平方以放大误差，并消除负值差距的影响</li>
                <li>平方后的值求和，得到总平方误差</li>
                <li>总平方误差除以样本数得到方差</li>
            </ol>
            <div class="overflow-auto"><span class="text-blue-math">\[ \text{Variance} = \frac{\text{SSE}_{Pixels_{Macroblock}} - (\text{SAD}_{Macroblock})^2}{Pixels_{Macroblock}} = \frac{\text{SSE}_{Pixels_{Macroblock}} - (\text{SAD}_{Macroblock})^2}{256} \]</span></div>

            <code class="code-bold">--aq-mode</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数 0~3&gt;据原画和 CRF/ABR 强度设定，码率不足时分配细分块量化强度的策略</p>
            <ul class="font-monospace pl-5 text-smaller">
                <li><span class="text-blue-emph">1</span>普通自适应量化，适用于简单平面以及快速编码场景</li>
                <li><span class="text-blue-emph">2</span>方差自适应量化，同时自动调整 <code>--aq-strength</code> 的强度。推荐用于录像电影，或搭配 CRF 小于 17，高码率 ABR 等不会欠码的策略</li>
                <li><span class="text-blue-emph">3</span>在欠码时倾向保暗场画质</li>
                <li><span class="text-blue-emph">4</span>在欠码时更加倾向保纹理画质（接受平面涂抹失真，动漫和幻灯片录屏场景慎用）</li>
            </ul>
            <code class="code-bold">--aq-strength</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;浮点&gt;自适应量化强度，推荐搭配 <code>--aq-mode</code> 使用。如动漫和幻灯片录屏等平面多过纹理的场景下 <code>--aq-mode <span class="text-blue-emph">1</span> --aq-strength <span class="text-blue-emph">0.8</span></code>, <span class="text-blue-emph">2</span>:<span class="text-blue-emph">0.9</span>，<span class="text-blue-emph">3</span>:<span class="text-blue-emph">0.7</span></p>
            <ul class="font-monospace pl-5 text-smaller">
                <li>录像或更复杂上如果不愿降低 CRF/增加 ABR 码率，则额外增加 <span class="text-blue-emph">0.1~0.2</span></li>
                <li>注意低成本动漫和幻灯片录屏等平面多过纹理的画面，因此码率不足时反而要更改量化强度分配策略为妥协纹理</li>
            </ul>
           
            <h2 id="h2-11">模式决策、环路滤镜</h2>
            <p>由于 AVC x264 的环路滤镜步骤中只有去块，所以准确的说就是“去块失真滤镜/去块滤镜（Deblock）”。之所以称作“环路/Loop”是因为编码器会在这之后进行模式决策（Mode Decision）来检查编码选用的帧内、帧间模式是否合理，于是，概念图中就出现了一条走向“倒过来回到动态搜索步骤结束为止”之后的“环路”路径，而这条路径上恰好有去块滤镜。当然，在更先进的视频编码上还有更多可用的滤镜，因此称为“滤镜组”。</p>
            <p>环路滤镜作用在重建帧（编码结果）上，使其成为未来帧的参考。模式决策（帧内模式、运动矢量、块划分等）都在编码当前块时完成，不会在环路滤镜处理之后再复查和修改。但编码器在决策时通常会基于“滤镜处理后的参考帧”来进行运动估计和预测，以保证和解码端一致。模式决策对于帧内编码的块/帧尤其重要，因为帧内预测的模式是根据重建（并滤波）后的左侧、左上和顶部相邻像素做的（信息有限），因此很可能还有更好的编码模式可取。对于帧间编码的块，其前后的参考帧已经进行过滤镜处理（因为编解码顺序不同于播放顺序），因此编码器可以安全地根据处理后的参考帧复查动态向量。</p>
            <ol>
                <li><b>整合动态搜索与补偿可能性</b>：
                    <ul>
                        <li>计算并收集每种帧内，帧间预测模式的率失真分数（于下文解释）</li>
                    </ul>
                </li>
                <li><b>整合分块参考量化可能性</b>：
                    <ul>
                        <li>计算并收集每种细分块方案（4x4，8x8，16x16），参考帧长度，量化强度下的率失真分数</li>
                    </ul>
                </li>
                <li><b>压缩方案定制</b>：
                    <ul>
                        <li>选择码率最小的压缩方案并不是最优解，因此找出率失真分数最高的方案集，得到码率与画质最为平衡的方案</li>
                    </ul>
                </li>
            </ol>
            <!-- x264 教程副本，更改需手动同步 { -->
            <h3>去块滤镜</h3>
            <p>修复“CRF/ABR 模式在某些场景的部分区域里分配量化值过高时，宏块间出现明显横纵割痕瑕疵”的平滑滤镜。编码器内去块利用了帧内帧间搜索到的信息，而理论上相比外部滤镜误判更少（当然外部滤镜也能做动态和帧内搜索）。去块大体上是检查 1 像素宽，且此块边缘没有较大像素值变化造成的横纵边缘（所以也存在误判）。块失真源自块间不统一的量化程度，有的块量化高流就会从邻近画面里凸现出来。而去块手段是平滑滤镜，因此要降低强度才适用于高码视频，动漫，素材录屏等锐利画面。边界强度 Boundary strength（去块力度判断）</p>
            <div class="align-items-center">
                <img src="files/deblocking/Deblock-detection-visualization.png" alt="Deblock-detection-visualization" class="img-medium">
                <img src="files/deblocking/Deblock-edge-visualization.png" alt="Deblock-edge-visualization" class="img-medium">
                <p class="text-gray-side">图：取最小 8x8 范围（两个 4x4 分块）间的界线举例。</p>
            </div>

            <ul class="text-smaller">
                <li>平滑 4：a 与 1 皆为帧内块，且边界位于 CTU/宏块间，最强滤镜值</li>
                <li>平滑 3：a 或 1 皆为帧内块，但边界不在 CTU/宏块间</li>
                <li>平滑 2：a 与 1 皆非帧内块，含一参考源/已编码系子</li>
                <li>平滑 1：a 与 1 皆非帧内块，皆无参考源/已编码系子，溯异帧或动态向量相异</li>
                <li>平滑 0：a 与 1 皆非帧内块，皆无参考源/已编码系子，溯同帧或动态向量相同，滤镜关</li>
            </ul>

            <code class="code-bold">--deblock</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;浮点偏移值，默认 1:0。推荐 0:0，-1:-1，-2:-1&gt; 平滑强度：搜索精度。两值于原有强度上增减。</p>
            <ul class="font-monospace pl-5 text-smaller">
                <li>平滑<span class="text-blue-emph">≥1</span>时用以压缩</li>
                <li>平滑<span class="text-blue-emph">-2~-1</span>时略降锐度，适合串流</li>
                <li>平滑<span class="text-blue-emph">2</span>适合锐利视频源，4k 电影，游戏录屏。提高码率且会出现块失真</li>
                <li>平滑<span class="text-blue-emph">-3~-2</span>适合高码动画源/桌面录屏。增块失真，但观感仍比 1 好</li>
                <li>搜索<span class="text-blue-emph">大于 2</span>易误判；<span class="text-blue-emph">小于 1</span>会遗漏。建议保持<span class="text-blue-emph">0~-1</span>，除非量化强度大于 26 时设设<span class="text-blue-emph">1</span></li>
            </ul>
            <!-- } -->

            <h2 id="h2-12">优化量化策略</h2>
            <!-- x264 教程副本，更改需手动同步 { -->
            <h3>率失真优化 Rate distortion optimization（RDO）</h3>
            <p>视频压缩策略受到算力、分析算法、客户等诸多限制，尽管工程师和开发者付出了很多努力，最后也往往回归最直接的“码率越小越好”——给所有压缩步骤选择码率最小的编码模式，或者强行上马一个 CQP 就完事。这样做的结果是码率分配失衡，即“码率在握之画质全损”，而“码率在握”也只是因为作对比的是无损或未压缩视频源；实际上，如此“粗压”与“精压”相比还会露馅——后者在画质更高的情况下，码率往往更低。原因是 <i>过度的有损压缩使得本可用于无损压缩（冗余）的机会被因小失大地浪费</i>。例如，过度的量化会破坏 P-B 帧原本可以参考 I 帧的部分，由于差异太大，编码器只得放弃参考，把这个区域重编码为 I 块，或直接改成 I 帧。</p>
            <p>现代视频编码器已经具备了减免这种问题所需的信息——编码后失真、码率代价，以及编码后码率。将失真，码率分别看做两种“越大越差”的程度，再根据码率代价——“此处码率的宝贵程度”缩放出一个一元一次函数空间（<span class="text-blue-math">\(y = mx + b\)</span>），问题就迎刃而解——只要找到各种 <span class="text-blue-math">\(mx + b\)</span> 里最小的  <span class="text-blue-math">\(y\)</span> 即可，而“找到最小”的过程需要统计每个编码步骤下的多个至全部编码模式，这个过程就是率失真优化（RD）。率失真优化的性能占用虽然不小，但它带来的好处可以和动态搜索相媲美。</p>
            <p>“编码器策略”就是模式决策。率失真程度由代价函数「开销 = 失真+λ⋅码率」（越小越好）得出：</p>
            <span class="text-blue-math text-larger">\[J = D + \lambda \cdot R\]</span>
            <p>编码器在决定采用哪种编码模式（如帧内/帧间、哪种块划分、运动矢量朝向等）时，不再只考虑码率 R 或失真 D，而是计算所有候选模式的率失真代价 <span class="text-blue-math">\(J = D + \lambda R\)</span>，然后选择代价 J 最小的那个模式。</p>
            <ul>
                <li><span class="text-blue-math">\(\lambda=0\)</span>：无斜度，则代价等于失真——码率变而画质不变，宜压缩</li>
                <li><span class="text-blue-math">\(\lambda \rightarrow 0\)</span>：趋 0，则开销趋失真——宜适当压缩</li>
                <li><span class="text-blue-math">\(\lambda &gt;0\)</span>：大于 0，则开销大于失真——保画质收益大于压缩收益，宜保画质</li>
            </ul>
            <!-- } -->
            <div class="align-items-center">
                <img src="files/rate-distorsion-optimization/x264-JM-RDO-Lambda.png" alt="x264-JM-RDO-Lambda" class="img-medium">
                <img src="files/rate-distorsion-optimization/RDO-Lambda-Slopes.png" alt="RDO-Lambda-Slopes" class="img-medium">
                <p class="text-gray-side">图：率失真优化中λ的斜度变化与效果</p>
                <img src="files/rate-distorsion-optimization/RDO-qStep-Chart.png" alt="RDO-qStep-Chart" class="img-medium">
                <p class="text-gray-side">图：率 - 失真表格中不断调整并得到“×”的实际效果</p>
            </div>
            <code class="code-bold">--fgo</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数默认关，推荐 15 左右&gt;将高频信号在量化前后的差距也算进率失真优化的统计中，使优化更倾向于保留细节和噪声</p>

            <h3>心理视觉优化</h3>
            <p>Psycho-visual optimization PVO 更类似于一种自适应量化，利用人类视觉系统的特性，通过掩蔽和感知量化量化，实现低码画面的码率再分配，保持高压缩的同时，提供更好的主观视觉质量。主观质量是建立在损失客观质量（与输入源的差距）上的质量。</p>
            <ol>
                <li><b>空间掩蔽 Spatial Masking</b>：
                    <ul>
                        <li>人眼会忽略高锐度边缘周边区域的画面，因此增加这些区域的量化强度</li>
                    </ul>
                </li>
                <li><b>频域掩蔽 Frequency Masking</b>：
                    <ul>
                        <li>人眼会忽略高频细节区域内的低频信号分量，因此可以在变换块中剔除高频块的低频分量</li>
                    </ul>
                </li>
            </ol>
            <code class="code-bold">--psy-rd</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;a:b 浮点，默认 1:0&gt;心理学优化设置。a 保留纹理，b 在 a 的基础上保留噪点细节，ab 值据画面复杂度拉高，</p>
            <ul class="font-monospace pl-5 text-smaller">
                <li>低成本动漫与幻灯片录屏画面：<span class="text-blue-emph">0.4:0.1</span>~<span class="text-blue-emph">0.6:0.15</span></li>
                <li>电影，录像等场景：<span class="text-blue-emph">0.7:0.12</span>~<span class="text-blue-emph">1.3:0.2</span></li>
                <li><code>--no-mbtree</code> 可将 b 设置为 <span class="text-blue-emph">0</span></li>
            </ul>
            <code class="code-bold">--no-psy</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;开关&gt;若视频量化很低，纹理清楚，没有优化的必要可以关。但大部分情况下不应该关，而是用较低的优化强度</p>
            <div class="align-items-center">
                <img src="files/rate-distorsion-optimization/Principle-on-Image-Quality.png" alt="Principle-on-Image-Quality" class="img-small">
                <p class="text-gray-side">图：心理视觉优化保留高频信号，同时压缩周围和其中的非高频信号</p>
            </div>

            <h3>宏块树与量化值曲线缩放 qComp</h3>
            <p>源自 libavcodec 实现同码率下整体画质更高结果的逻辑：“复杂动态场景的帧间参考少。所以分配更少码率（增加量化压缩），更多码率应该分给参考多而远的简单动态场景”。这样做在码率受到很大限制时能保护多数场景的画质，但缺点则是大多时候，动漫场景等「背景不动前景动」的场景（如人物脸部）画面被压缩太多的问题。x264 中所做的改进是“逐宏块应用这套逻辑”——即 <a href="https://web.archive.org/web/20150224032942/http:/x264dev.multimedia.cx/archives/98">MarcoBlock Tree（mbtree）</a>。量化值曲线缩放 quantizer curve compression 则被“贬为”控制 mbtree 等一系列量化强度分配算法中的一个缩放参数，见 <a href="https://www.desmos.com/calculator/aa7rsjuxkr">desmos 互动例</a>。</p>
            <h4>qComp 的用途</h4>
            <ol class="overflow-auto">
                <li>（ABR 模式）根据宏块的数量与 <code>--qcomp</code> 值设置初始复杂度百分比：
                    <span class="text-blue-math">\[ \text{Complexity} = \left( \frac{\text{Count}_{MB}}{2} \right) ×700000^{\left( \frac{qcomp}{100} \right)} \div 100 \]</span>
                </li>
                <li>获取当前场景的长度 <span class="text-blue-math">\( \text{Duration}_{clip} \)</span></li>
                <li>当前帧与下一帧间的图像模糊后做 SATD，获得「模糊复杂度 <span class="text-blue-math">\( \text{Complexity}_{blurred} \)</span>」</li>
            </ol>
            <ul class="overflow-auto">
                <li>（关 mbtree 时）使用 <code>--qcomp</code> 缩放模糊复杂度，以换算出当前帧的 qScale：
                    <span class="text-blue-math">\[ \text{qScale} = \left( \text{Complexity}_{blurred} \right)^{1-qcomp} \]</span>
                </li>
                <li>（开 mbtree 时）据 I 帧在当前片段的权重设单帧量化强度（基准单帧用时 ÷ 当前场景用时 × I 帧用时 ÷ 帧率）：
                    <span class="text-blue-math">\[ \text{qScale} = Duration_{frame} \div Duration_{clip}\times Duration_{iframe} \div \text{fps} \]</span>
                </li>
            </ul>
            <code class="code-bold">--qcomp</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;浮点范围 0.5~1，推荐默认 0.6&gt;模糊复杂度 cplxBlur 以及 mbtree 迭代每帧量化强度范围的曲线抑制参数。越小则复杂度迭代越符合实际状况，抑制 CRF，mb/cutree，bframes 影响的效果就越弱，搭配高 CRF 能使码率控制接近 VBV 的程度。越大则 CRF，mb-cutree，bframes 越没用，越接近 CQP</p>
            <ul class="font-monospace pl-5 text-smaller">
                <li><span class="text-blue-emph">小于 0.5，中~强 mbtree</span> CRF/ABR低延迟逐帧迭代qp; 画面主前景动时用，允许 mbtree 导致零星宏块欠码</li>
                <li><span class="text-blue-emph">0.5~0.7 中 mbtree</span> CRF/ABR中延迟逐帧迭代qp, 画面含背景动，或混合情况用，平衡优先</li>
                <li><span class="text-blue-emph">大于 0.7 中~弱 mbtree</span> CRF, ABR 中~高延迟逐帧迭代量化强度, 保留重噪点，或 FPS/STG 游戏录屏场景用</li>
                <li><span class="text-blue-emph">小于 0.5 关 mbtree</span> 画面不分前背景，如静态图像，PPT/桌面录屏节约性能用</li>
                <li><span class="text-blue-emph">大于 0.5 关 mbtree</span> 动态画面，不分前背景时节约性能用</li>
                <li><span class="text-blue-emph">0</span>（if 判定）启用固定码率模式</li>
                <li><span class="text-blue-emph">1</span>（if 判定）启用固定量化强度模式</li>
            </ul>

            <h4>宏块树 Macroblock-Tree</h4>
            <p>如果一个宏块用作帧间参考的码率比用作帧内参考低 70%，则该宏块可视为 30% 非帧间参考和 70% 帧间参考两部分。已知帧间参考占据的部分越多，则这个宏块自身就没有多少信息；而在宏块树所运行的时间，这个宏块是位于软转场 GOP 末尾——scenecut 步骤之后，keyint 步骤之前。因此，可以增强其压缩——把更多的码率分给参考传播最远的 I 帧，以提拔整个软转场 GOP 的画质。详见 <a href="http://lazybing.github.io/blog/2021/06/22/h264-rate-control-algorithm/">x264 率控制算法</a> 及 <a href="https://huyunf.github.io/blogs/2017/12/06/x264_slice_type_decision/MBtree paper.pdf">mbtree paper</a>。</p>
            <p>由于宏块树的步骤位于前瞻进程 Lookahead 中，而前瞻进程位于动态搜索和运动补偿之前，且 Lookahead 只使用半分辨率的视频帧，因此，此时的宏块树只能额外尝试简单的帧内和帧间预测。</p>
            <ul>
                <li>注：帧间参考代价只能小于等于帧内参考代价，类似于（同视频下的）P 帧体积不应大于 I 帧
                    <ul class="text-smaller">
                        <li>若出现帧间参考代价大于帧内参考代价的情况，就重设为「帧间参考代价等于帧内参考代价」</li>
                    </ul>
                </li>
            </ul>
            <p>宏块帧内和帧间的参考代价记为 <span class="text-blue-math">\(\text{Cost}_{intra}\)</span> 和 <span class="text-blue-math">\(\text{Cost}_{inter}\)</span>，通过 Lookahead 中以下“搜索”步骤得到：</p>
            <ul>
                <li><b>简单帧内预测/宏块自身信息量预测：</b>尝试水平和垂直模式
                    <ul class="text-smaller">
                        <li>水平模式：得到残差为 2，代价为 4</li>
                        <li>垂直模式：得到残差为 3，代价为 5</li>
                        <li>选择水平模式，记 <span class="text-blue-math">\(\text{Cost}_{intra}\)</span> 代价为 4</li>
                    </ul>
                </li>
                <li><b>简单帧间预测/宏块参考信息量预测：</b>以上一帧为参考，进行运动估计
                    <ul class="text-smaller">
                        <li>运动矢量 (1,1)：得到残差为 1，代价为 2</li>
                        <li>运动矢量 (2,2)：得到残差为 2，代价为 3</li>
                        <li>选择运动矢量 (1,1)，记 <span class="text-blue-math">\(\text{Cost}_{inter}\)</span> 代价为 2</li>
                    </ul>
                </li>
                <li><b>宏块总代价：</b>自身代价 + 上一帧帧间预测代价 <span class="text-blue-math">\( \text{Cost}_{intra} + \text{Cost}_{inter} \)</span>
                    <ul class="text-smaller">
                        <li><b>上一帧帧间预测代价：</b>上一帧的宏块与当前帧宏块匹配帧间预测模式所得的代价</li>
                    </ul>
                </li>
                <li><b>溯块总代价：</b>自身代价 + 下一帧帧间预测代价 <span class="text-blue-math">\( \text{Cost}_{intra} + \text{Cost}_{propagate} \)</span>
                    <ul class="text-smaller">
                        <li><b>下一帧帧间预测代价：</b>下一帧的宏块与当前帧宏块匹配帧间预测模式所得的代价 + <span class="text-blue-math">\(\text{Propagate}_{amount}\)</span> 累积的代价</li>
                        <li>由于 B 帧是双向参考帧，所以不存在「上/下一帧帧间预测代价」，而是「参考帧/被参考帧间预测代价」</li>
                    </ul>
                </li>
            </ul>
            <ol>
                <li><b>设定：</b>各个宏块自身代价与参考代价的比率，再从 100% 减掉这个比率，得到给其他宏块参考的信息比率
                    <span class="text-blue-math"> \[ \text{propagate}_{fraction}=1-\left(\frac{\text{Cost}_{intra}}{\text{Cost}_{inter}}\right) \]</span>
                </li>
                <li><b>设定：</b>各个宏块传播到下游宏块的代价量 = 给其他宏块参考的信息比率 × 溯块总代价
                    <span class="text-blue-math"> \[ \text{Propagate}_{amount} = \text{Propagate}_{fraction} \times (\text{Cost}_{intra} + \text{Cost}_{propagate}) \]</span>
                    <ul class="text-smaller">
                        <li><span class="text-blue-math">\( \text{Propagate}_{fraction} \)</span> 越小，传播到下游宏块的信息量就越少</li>
                        <li><span class="text-blue-math">\( \text{Cost}_{intra} + \text{Cost}_{propagate} \)</span> 越大，传播到下游宏块的信息量就越大</li>
                    </ul>
                </li>
                <li><b>计算：</b>从最远范围 <code>--rc-lookahead</code> 开始，从远到近地累积所有宏块的 <span class="text-blue-math">\( \text{Propagate}_{amount} \)</span>，作为统计列表中下一个宏块的 <span class="text-blue-math">\( \text{Cost}_{propagate} \)</span>
                    <ul class="text-smaller">
                        <li>这里非常绕，总之就是「传播到下游宏块的信息量 <span class="text-blue-math">\( \text{Propagate}_{amount} \)</span>」是持续更新累积的过程，而不是从当前帧往后查找传播了多少信息</li>
                        <li>如果出现动态位移（当前宏块的范围被切分到下帧的 4 个宏块之间时），这 4 个宏块会各自按比例拆分出各自的传播信息量</li>
                    </ul>
                </li>
                <li><b>分配：</b>从最远范围 <code>--rc-lookahead</code> 开始，从远到近地根据已有的 <span class="text-blue-math">\( \text{Cost}_{propagate} \)</span> 和自身的信息量 <span class="text-blue-math">\( \text{Cost}_{intra} \)</span>，通过 <span class="text-blue-math">\( \log_{2}() \)</span> 非线性地映射到量化强度，得到宏块树中每个宏块的量化值偏移：
                    <span class="text-blue-math"> \[ \Delta \text{QP} = -\text{strength} \times \log_{2}\left( \frac{\text{Cost}_{intra}}{\text{Cost}_{propagate}} \right) \div \text{Cost}_{intra} \]</span>
                </li>
            </ol>
            <p class="text-gray-side">大部分情况下 mbtree 偏移值为零，因为宏块没有溯块信息可用</p>
            <!-- x265 教程副本，需要手动同步更改 { -->
            <code class="code-bold">--rc-lookahead</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;帧数量，范围 1~250，推荐 keyint÷2&gt; 指定 cutree 的检索帧数，通常设在帧率的 2.5~3 倍。高则占用内存增加延迟，低则降低压缩率和平均画质。</p>
            <p class="text-gray-side pl-5 m-0 overflow-auto">注：mbtree/cutree 会自动选择 <code>--rc-lookahead</code> 和 <span class="text-blue-math text-smaller">\( \max\left( \text{keyint}, \max\left( \text{vbv-maxrate}, \text{bitrate}\right)\div\text{vbv-bufsize} \times \text{fps} \right) \)</span> 中最小的值作为检索帧数</p>
            <!-- } -->
            <code class="code-bold">--no-mbtree</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;开关&gt; 关闭少见宏块量化偏移。可能只有近无损，<code>--crf</code> 小于 16 才用的到。</p>

            <h2 id="h2-13">熵编码/文本压缩</h2>
            <p>x264 教程中仅提及最简单的形式。完成的熵编码流程见 <a href="../../x265-web-tutorial/HTML/index.html#h2-15">x265 教程网页版 - 熵编码</a>。</p>
            <h3>霍夫曼编码 Huffman Coding</h3>
            <p>曾经广泛应用于数据压缩的算法。步骤分为：</p>
            <ol>
                <li><b>统计频率</b>：
                    <ul class="font-monospace pl-5 text-smaller">
                        <li>在第一次遍历文本/pass1 时，只统计每个字符出现的次数，并按出现频率从小到大排序</li>
                    </ul>
                </li>
                <li><b>构建初始节点</b>：
                    <ul class="font-monospace pl-5 text-smaller">
                        <li>将每个字符和其出现频率作为一个节点，并将这些节点放入一个最小堆（优先队列）</li>
                    </ul>
                </li>
                <li><b>构建霍夫曼树</b>：
                    <ul class="font-monospace pl-5 text-smaller">
                        <li>从最小堆中取出两个频率最小的节点</li>
                        <li>创建一个新节点，其频率是这两个节点频率之和，将这两个节点作为新节点的子节点</li>
                        <li>将新节点插回最小堆中</li>
                        <li>重复上述步骤，直到堆中只剩下一个节点，这个节点就是霍夫曼树的根节点</li>
                    </ul>
                </li>
                <li><b>生成编码</b>：
                    <ul class="font-monospace pl-5 text-smaller">
                        <li>通过遍历霍夫曼树，为每个字符生成霍夫曼编码。通常向左的节点表示为向 0，向右的节点表示为向 1</li>
                    </ul>
                </li>
            </ol>

            <h4>霍夫曼编码的例子</h4>
            <p>来源：<a href="https://www.geeksforgeeks.org/huffman-coding-greedy-algo-3/">geekforgeeks - greedy3</a> 算法。假设第一次遍历文本得到了如下字符及其频率：</p>

            <table class="table-center align-items-center font-monospace pl-5 text-smaller">
                <thead>
                    <th class="px-3">字符</th><th class="px-3">频率</th>
                </thead>
                <tbody>
                    <tr class="border-bottom">
                        <td>A</td><td>5</td>
                    </tr>
                    <tr class="border-bottom">
                        <td>B</td><td>9</td>
                    </tr>
                    <tr class="border-bottom">
                        <td>C</td><td>12</td>
                    </tr>
                    <tr class="border-bottom">
                        <td>D</td><td>13</td>
                    </tr>
                    <tr class="border-bottom">
                        <td>E</td><td>16</td>
                    </tr>
                    <tr>
                        <td>F</td><td>45</td>
                    </tr>
                </tbody>
            </table>
            <ol>
                <li><b>统计频率</b>：已完成</li>
                <li><b>构建初始节点</b>：
                    <ul>
                        <li>据出字次数从小到大排序：<span class="text-blue-math">(5,'a'),(9,'b'),(12,'c'),(13,'d'),(16,'e'),(45,'f')</span></li>
                    </ul>
                </li>
                <li><b>构建霍夫曼树</b>：
                    <ol>
                        <li>取出字次数最小的两个元素 (5, 'a'), (9, 'b')，合为 (14, 'ab')
                            <ul class="text-smaller">
                                <li>得 (12, 'c'), (13, 'd'), (16, 'e'), (45, 'f'), (14, 'ab')</li>
                                <li><img src="files/huffman-coding/1.png" alt="huffman-coding-1" class="img-small"></li>
                            </ul>
                        </li>
                        <li>取出字次数最小的两个元素 (12, 'c'), (13, 'd')，合并为 (25, 'cd')
                            <ul class="text-smaller">
                                <li>得 (14, 'ab'), (16, 'e'), (45, 'f'), (25, 'cd')</li>
                                <li><img src="files/huffman-coding/2.png" alt="huffman-coding-2" class="img-small"></li>
                            </ul>
                        </li>
                        <li>取出字次数最小的两个元素 (14, 'ab'), (16, 'e')，合并为 (30, 'abe')
                            <ul class="text-smaller">
                                <li>得 (25, 'cd'), (45, 'f'), (30, 'abe')</li>
                                <li><img src="files/huffman-coding/3.png" alt="huffman-coding-3" class="img-medium"></li>
                            </ul>
                        </li>
                        <li>取出字次数最小的两个元素 (25, 'cd'), (30, 'abe')，合并为 (55, 'cdeab')
                            <ul class="text-smaller">
                                <li>得 (45, 'f'), (55, 'CDEAB')</li>
                                <li><img src="files/huffman-coding/4.png" alt="huffman-coding-4" class="img-medium"></li>
                            </ul>
                        </li>
                        <li>取出字次数最小的两个元素 (45, 'f'), (55, 'cdeab')，合并为 (100, 'fcdeab')
                            <ul class="text-smaller">
                                <li>得 (100, 'FCDEAB')</li>
                                <li><img src="files/huffman-coding/5.png" alt="huffman-coding-5" class="img-medium"></li>
                            </ul>
                        </li>
                    </ol>
                </li>
                <li><b>生成编码</b>：
                    <ul>
                        <li>从霍夫曼树根节点开始，为每个字符生成霍夫曼编码：</li>
                    </ul>
                </li>
            </ol>
            <table class="table-center align-items-center font-monospace pl-5 text-smaller">
                <thead>
                    <th class="px-3">字符</th><th class="px-3">编码</th>
                </thead>
                <tbody>
                    <tr class="border-bottom">
                        <td>F</td><td>0</td>
                    </tr>
                    <tr class="border-bottom">
                        <td>C</td><td>1-0-0</td>
                    </tr>
                    <tr class="border-bottom">
                        <td>D</td><td>1-0-1</td>
                    </tr>
                    <tr class="border-bottom">
                        <td>A</td><td>1-1-0-0</td>
                    </tr>
                    <tr class="border-bottom">
                        <td>B</td><td>1-1-0-1</td>
                    </tr>
                    <tr>
                        <td>E</td><td>1-1-1</td>
                    </tr>
                </tbody>
            </table>
            <p>从上面的内容可见，熵编码是一种无损压缩（例如代码和小说都是文本，文本编码不可更改其内容）。既然是无损，那么不同的熵编码算法之间就只有编码速度和压缩率两个判断标准。x264 中使用了上下文自适应可变长度编码 Context Adaptive Variable Length Coding 和压缩率更高，速度慢一点的上下文自适应二进制算数编码 Context Adaptive Binary Arithmetic Coding CABAC。CABAC 的原理见 <a href="../../x265-web-tutorial/HTML/index.html#h2-15">x265 教程网页版 - 熵编码</a></p>
            <code class="code-bold">--no-cabac</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;开关，不推荐&gt;关闭 CABAC，使用 CAVLC</p>

            <h2 id="h2-14">优化熵编码</h2>
            <h3>残差 DCT 系子</h3>
            <p>Residual DCT coefficients 代表变换后量化前，已知经过量化后会被抹除的 DCT 系子。DCT 变换的例子见本教程的 <a href="#h2-7">变换 - DCT 变换</a> 部分。总之就是与“残差块”无关，只是都叫做残差而已。</p>

            <h3>编码块标记 CBF</h3>
            <p>Coded block flag 会被标在预测和/或与其相应的变换单元（亮度块加色度块）中表示该单元是否附有较多的残差系子：CBF=1 代表有、0 代表没有。引导四叉树 quadtree 算法进一步分枝——宏块向下分块。详见 <a href="https://patents.google.com/patent/US9749645B2/en">US9749645B2</a>。</p>
            <div class="align-items-center">
                <img src="files/entropy-coding-optimization/Quad-tree-bitmap.svg" alt="Quad-tree-bitmap" class="img-medium">
                <p class="text-gray-side">图：四叉树的分块。见<a href="https://en.wikipedia.org/wiki/Quadtree">维基百科</a></p>
            </div>

            <h3>DCT 归零优化 Decimate</h3>
            <p>由上可知，录像与电影片源中的动态噪点会直接干扰编码器的分块，导致熵编码总是要处理系子数量少的 8x8，4x4 分块，而 x264 设计时面向了 640x480 分辨率的视频，所以就有了专门用于避免无效分块，避免性能和熵编码压缩率被浪费的系子归零处理（现已淘汰但默认开启）。具体是：</p>
            <ol class="text-smaller">
                <li>8x8 亮度块中分量为 -3~3 的 DCT 系子归零</li>
                <li>16x16 亮度块中分量为 -5~5 的 DCT 系子归零</li>
                <li>色度块中分量为 -6~6 的 DCT 系子归零</li>
                <li>优化后的块回到原来的编码步骤——量化中</li>
            </ol>
            <code class="code-bold">--no-dct-decimate</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;开关，默认关&gt;关闭 DCT 变换的低强度系子归零操作，以减少细节损失，降低有损压缩。适合幻灯片录屏等画面极其干净，或经过大量滤镜过滤噪声，<code>--crf &lt; 17</code>或 ABR <code>--bitrate &gt; 500000</code> 编码策略的源视频</p>
            
            <h3>死区量化器 Dead-zone Quantizer 优化</h3>
            <p>死区，也叫 dead-band，netual-zone，或无作用区，代表输入到输出波形中可归零的部分。</p>
            <div class="align-items-center">
                <img src="files/entropy-coding-optimization/Deadband-operator.svg" alt="Deadband-operator" class="img-small">
                <p class="text-gray-side">图：信号死区设 0.5 时，输入到输出 <span class="text-blue-pure">y</span>=<span class="text-red-pure">x</span> 波形的变化。见<a href="https://en.wikipedia.org/wiki/Deadband">维基百科</a></p>
            </div>
            <p>死区量化器的用途同上。x264 中，<code>--trellis</code>没有完全开启（2）时，死区量化器会被替代启用。默认设置下：</p>
            <ol class="text-smaller">
                <li>帧间亮度块中，分量为 -21~21 的 DCT 系子归零</li>
                <li>帧内亮度块中，分量为 -11~11 的 DCT 系子归零</li>
                <li>优化后的块回到原来的编码步骤——量化中</li>
            </ol>
            <p>因此，结果是在高分辨率下，默认设置对画面细节的涂抹较强，所以一般建议 <code>--trellis 2</code>，或在最少大于等于 1600x900 分辨率、<code>--trellis &lt; 2</code> 的时候更改死区量化器相关参数的默认值。</p>
            <code class="code-bold">--deadzone-inter</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数 0~32，默认 21，<code>--trellis</code> 小于 2 时开启&gt;一种逻辑简单的帧间再量化——细节面积小于死区就删掉，大就保留。一般用途建议 8，高画质建议 6</p>
            <code class="code-bold">--deadzone-intra</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数 0~32，默认 11，<code>--trellis</code> 小于 2 时开启&gt;一种逻辑简单的帧间再量化——细节面积小于死区就删掉，大就保留。一般用途建议 8，高画质建议 4</p>

            <h3>软判决率失真游程走线优化 - SDQ trellis</h3>
            <p>Soft decision quantization / SDQ trellis 算法。通过限制量化后块中的 DCT 系子 coefficients 强度，甚至偏移当前系子的强度值到临近系子，以保证游程编码中走线的平稳。过程中由率失真计算确认对画面的影响符合预期质量，从而提高压缩率。<code>--trellis</code> 应用于量化步骤之后，并且对少数突兀的 DCT 系子强度做了平均化，所以叫“再量化”。详见 <a href="../../x265-web-tutorial/HTML/index.html#h2-16"></a>x265 教程 - 优化熵编码</p></p>
            <code class="code-bold">--trellis</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数，范围 0~2, 推荐 2&gt;软判决优化 CABAC 的率失真再量化。 </p>
            <ul class="font-monospace pl-5 text-smaller">
                <li><span class="text-blue-emph">1</span>调整模式决策 mode decision 处理完的块，快速压制用</li>
                <li><span class="text-blue-emph">2</span>同时调整帧内帧间参考和分块完成的块，效果最好</li>
            </ul>

            <h2 id="h2-15">色彩信息</h2>
            <p>重复一开始说明的物理亮度：可见光电磁波的强度或振幅，以流明 lumen/lm，坎德拉/烛光量 candela/cd，或尼特 nits/cdm<sup>2</sup> 计量：</p>
            <ul class="text-gray-side">
                <li>1cd/lm 大约为一支普通蜡烛的亮度。</li>
                <li>由于是强度，一般来说，灯泡电压越高、火药能量密度越高，发光就越明亮
                    <ul>
                        <li>因此定义：能量和光强/光压的相关性呈正比</li>
                    </ul>
                </li>
                <li>Nits 代表 1cd 光源投射到一平方米（一般情况下距离一米）区域后所剩的亮度，主要用于显示器的亮度设定。一般来说，<span class="text-blue-math">1 nit ≈ 3.426 lm</span>，但实际的换算关系取决于光源和测量仪器的不同与误差。</li>
            </ul>
            <!-- x265 教程副本，更改需手动同步 {-->
            <h3>高动态范围 High Dynamic Range HDR</h3>
            <p>原本是高端音响的标准，代表最小音量下没有一点电流噪声，最大音量可以和真实场景媲美的性能。与扬声器的大小和材质是否匹配场景相关，即「重硬件轻软件」。因为只要硬件达到 HDR 1000 规格，那么只要调高亮度就可以了；而随便一个中位水平的电视/显示器/手机屏幕亮度都能达到 HDR 400 标准。</p>
            <p>HDR 信息分为硬件、软件、以及数据，共 3 类不统一的标准。为保证色彩正确，压制时应额外检查并确保与视频源的一致性。如：</p>
            <div class="align-items-center">
                <img src="files/video-usability-information/Metadata-for-VUI-HDR-1.png" alt="Metadata-for-VUI-HDR-1" class="">
                <p class="text-gray-side">图 1: cll 1000,640. master-display 由 G(13250…) 开头，L(10000000,1) 结尾</p>
                <img src="files/video-usability-information/Metadata-for-VUI-HDR-2.png" alt="Metadata-for-VUI-HDR-2" class="img-medium">
                <p class="text-gray-side">图 2: cll 1655,117/L(40000000,50)/colorprim bt2020/colormatrix bt2020nc/transfer smpte2084</p>
            </div>
            <code class="code-bold">--master-display</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;G(x,y)B(,)R(,)WP(,)L(,)（绿，蓝，红，白点，光强）&gt;写进 SEI 信息里，告诉解码端色彩空间/色域信息用</p>
            <ul class="font-monospace pl-5 text-smaller">
                <li>HDR 标准设立时还没有 HDR 电视，所以就把 master-display 写成必须参数了，而最重要的信息反而是 cll。</li>
                <li>绿蓝红 GBR 和白点 WP 指马蹄形色域的三角 + 白点 4 个位置的值×50000</li>
                <li>光强 L 的单位是 candela×10000</li>
                <li>SDR 视频的 L 是 1000,1。压制 HDR 视频前一定要看视频信息再设 L，见上图
                    <ul>
                        <li>DCI-P3 电影业内：<span class="text-blue-emph">G(13250,34500)B(7500,3000)R(34000,16000)WP(15635,16450)L(?,1)</span></li>
                        <li>bt709：<span class="text-blue-emph">G(15000,30000)B(7500,3000)R(32000,16500)WP(15635,16450)L(?,1)</span></li>
                        <li>bt2020 超清：<span class="text-blue-emph">G(8500,39850)B(6550,2300)R(35400,14600)WP(15635,16450)L(?,1)</span></li>
                    </ul>
                </li>
                <li>RGB 原信息 (对照小数格式的视频信息，然后选择上面对应的参数):
                    <ul>
                        <li>DCI-P3：<span class="text-blue-emph">G(x0.265,y0.690),B(x0.150,y0.060),R(x0.680,y0.320),WP(x0.3127,y0.329)</span></li>
                        <li>bt709：<span class="text-blue-emph">G(x0.30,y0.60),B(x0.150,y0.060),R(x0.640,y0.330),WP(x0.3127,y0.329)</span></li>
                        <li>bt2020：<span class="text-blue-emph">G(x0.170,y0.797),B(x0.131,y0.046),R(x0.708,y0.292),WP(x0.3127,y0.329)</span></li>
                    </ul>
                </li>
            </ul>
            <!-- } -->

            <h3>Video Usability Information（VUI 元数据）</h3>
            <p>VUI 是元数据，播放器会读取这些元数据来选择特定的色彩空间播放视频，由于 HDR 视频的标准受到厂商竞争割据等因素，用户需要手动指定 HDR 参数到 VUI 中才能正确播放（不过，有时电视厂商会为了节省成本而只读取一小部分信息，如只读取 MaxCLL 和 MaxFall）。</p>
            <p>光强/光压 Candela 等于尼特，即<span class="text-blue-math">\(1 \text{cd} = 1 \text{nit}\)</span>。因 bt601，709，HDR-PQ，HLG 标准重视的亮度范围，曲线所异（偏亮或偏暗），故需要量化曲线，心理学优化，模式决策的重适配。</p>
            <code class="code-bold">--cll</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;最大内容光强，最大平均光强&gt;压制 HDR 源一定照源视频信息设，找不到不要用，见上图例。</p>
            <!-- x265 教程副本，更改需手动同步 {-->
            <code class="code-bold">--colorprim</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;字符&gt;播放用三原色 (以及白点) 指标，查看视频信息可知：bt470m，bt470bg，smpte170m，smpte240m，film，bt2020，smpte428，smpte431，smpte432。如图 1 为 bt.2020。</p>
            <code class="code-bold">--colormatrix</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;字符&gt;播放用矩阵格式/系数指标：fcc，bt470bg，smpte170m，smpte240m，GBR，YCgCo，bt2020c，smpte2085，chroma-derived-nc，chroma-derived-c，ICtCp。</p>
            <p class="text-gray-side pl-5 m-0">注：不支持 bt2020nc</p>
            <code class="code-bold">--transfer</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;字符&gt;传输特质：bt470m，bt470bg，smpte170m，smpte240m，linear，log100，log316，iec61966-2-4，bt1361e，iec61966-2-1，bt2020-10，bt2020-12，smpte2084，smpte428，arib-std-b67。</p>
            <p class="text-gray-side pl-5 m-0">上图图 2 的 PQ 即 st.2084 的标准，所以参数值为 smpte2084。</p>
            <!-- } -->

            <h2 id="h2-16">预设参数</h2>
            <code class="code-bold">--preset</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;ultrafast/superfast/veryfast/faster/fast/medium/slow/slower/veryslow/placebo&gt;见下：</p>
            <div class="overflow-auto">
                <table class="table-fit-container text-xs">
                    <thead>
                        <tr>
                            <th>参数\预设</th>
                            <th>ultrafast</th>
                            <th>superfast</th>
                            <th>veryfast</th>
                            <th>faster</th>
                            <th>fast</th>
                            <th>medium</th>
                            <th>slow</th>
                            <th>slower</th>
                            <th>veryslow</th>
                            <th>placebo</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr class="border-lr">
                            <th>b-adapt</th>
                            <td class="px-1">0</td>
                            <td class="px-1 t-invert-light" colspan="5">默认 1</td>
                            <td class="px-1 t-invert-dark" colspan="4">2</td>
                        </tr>
                        <tr class="border-lr">
                            <th>bframes</th>
                            <td class="px-1">0</td>
                            <td class="px-1 t-light-gray" colspan="7">默认 3</td>
                            <td class="px-1 t-invert-light">8</td>
                            <td class="px-1 t-invert-dark">16</td>
                        </tr>
                        <tr class="border-lr">
                            <th>direct</th>
                            <td class="px-1" colspan="6">默认 spatio</td>
                            <td class="px-1 t-invert-dark" colspan="4">auto</td>
                        </tr>
                        <tr class="border-lr">
                            <th>me</th>
                            <td class="px-1" colspan="2">dia</td>
                            <td class="px-1 t-light-gray" colspan="4">默认 hex</td>
                            <td class="px-1 t-invert-light" colspan="3">umh</td>
                            <td class="px-1 t-invert-dark">tesa</td>
                        </tr>
                        <tr class="border-lr">
                            <th>merange</th>
                            <td class="px-1" colspan="8">默认 16</td>
                            <td class="px-1 t-invert-dark" colspan="2">24</td>
                        </tr>
                        <tr>
                            <th>partitions</th>
                            <td class="px-1">none</td>
                            <td class="px-1 t-light-gray">i8x8,i4x4</td>
                            <td class="px-1 t-invert-light" colspan="5">默认 p8x8,b8x8,i8x8,i4x4</td>
                            <td class="px-1 t-invert-dark" colspan="3">all</td>
                        </tr>
                        <tr class="border-lr">
                            <th>rc-lookahead</th>
                            <td class="px-1" colspan="2">0</td>
                            <td class="px-1 t-light-gray">10</td>
                            <td class="px-1 t-light-gray">20</td>
                            <td class="px-1 t-light-gray">30</td>
                            <td class="px-1 t-invert-light">默认 40</td>
                            <td class="px-1 t-invert-light">50</td>
                            <td class="px-1 t-invert-dark" colspan="3">60</td>
                        </tr>
                        <tr class="border-lr">
                            <th>ref</th>
                            <td class="px-1" colspan="3">1</td>
                            <td class="px-1 t-light-gray" colspan="2">2</td>
                            <td class="px-1 t-invert-light">默认 3</td>
                            <td class="px-1 t-invert-light">5</td>
                            <td class="px-1 t-invert-light">8</td>
                            <td class="px-1 t-invert-dark" colspan="2">16</td>
                        </tr>
                        <tr class="border-lr">
                            <th>subme</th>
                            <td class="px-1">0</td>
                            <td class="px-1 t-light-gray">1</td>
                            <td class="px-1 t-light-gray">2</td>
                            <td class="px-1 t-light-gray">4</td>
                            <td class="px-1 t-invert-light">6</td>
                            <td class="px-1 t-invert-light">默认 7</td>
                            <td class="px-1 t-invert-light">8</td>
                            <td class="px-1 t-invert-light">9</td>
                            <td class="px-1 t-invert-light">10</td>
                            <td class="px-1 t-invert-dark">11</td>
                        </tr>
                        <tr class="border-lr">
                            <th>trellis</th>
                            <td class="px-1" colspan="3">0</td>
                            <td class="px-1 t-invert-light" colspan="3">默认 1</td>
                            <td class="px-1 t-invert-dark" colspan="4">2</td>
                        </tr>
                        <tr class="border-lr">
                            <th>weightp</th>
                            <td class="px-1">0</td>
                            <td class="px-1 t-invert-light" colspan="4">1</td>
                            <td class="px-1 t-invert-dark" colspan="5">默认 2</td>
                        </tr>
                        <tr class="border-lr">
                            <th>no-weightb</th>
                            <td class="px-1">1</td>
                            <td class="px-1 t-invert-light" colspan="9">默认 0</td>
                        </tr>
                        <tr class="border-lr">
                            <th>no-8x8dct</th>
                            <td class="px-1">1</td>
                            <td class="px-1 t-invert-light" colspan="9">默认 0</td>
                        </tr>
                        <tr class="border-lr">
                            <th>no-cabac</th>
                            <td class="px-1">1</td>
                            <td class="px-1 t-invert-light" colspan="9">默认 0</td>
                        </tr>
                        <tr class="border-lr">
                            <th>no-deblock</th>
                            <td class="px-1">1</td>
                            <td class="px-1 t-invert-light" colspan="9">默认 0</td>
                        </tr>
                        <tr class="border-lr">
                            <th>no-mbtree</th>
                            <td class="px-1" colspan="2">1</td>
                            <td class="px-1 t-invert-light" colspan="8">默认 0</td>
                        </tr>
                        <tr class="border-lr">
                            <th>no-mixed-refs</th>
                            <td class="px-1" colspan="4">1</td>
                            <td class="px-1 t-invert-light" colspan="6">默认 0</td>
                        </tr>
                        <tr class="border-lr">
                            <th>scenecut</th>
                            <td class="px-1">0</td>
                            <td class="px-1 t-invert-light" colspan="9">默认 40</td>
                        </tr>
                        <tr class="border-lr">
                            <th>no-fast-pskip</th>
                            <td class="px-1" colspan="9">默认 0</td>
                            <td class="px-1 t-invert-light">1</td>
                        </tr>
                        <tr class="border-lr">
                            <th>slow-first-pass</th>
                            <td class="px-1" colspan="9">默认 0</td>
                            <td class="px-1 t-invert-light">1</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <code class="code-bold">--tune</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;zerolatency/animation/grain/film/fastdecode/psnr/ssim&gt;更改 preset 的一些参数，见下：</p>
            <ul class="font-monospace pl-5 text-smaller">
                <li><span class="text-blue-emph">zerolatency</span>集中算力到一次编码一帧，并尽可能关闭率控制和 B 帧功能：
                    <ul>
                        <li><code>--bframes 0 --force-cfr --no-mbtree --sync-lookahead 0 --sliced-threads --rc-lookahead 0</code></li>
                    </ul>
                </li>
                <li><span class="text-blue-emph">grain</span>保留高频信号/最高画质：
                    <ul>
                        <li><code>--deblock -2:-2 --psy-rd &lt;跳过&gt;:0.25 --aq-strength 0.5 --no-dct-decimate --deadzone-inter 6 --deadzone-intra 6 --ipratio 1.1 --pbratio 1.1 --qcomp 0.8</code></li>
                    </ul>
                </li>
                <li><span class="text-blue-emph">animation</span>优化动漫场景画面：
                    <ul>
                        <li><code>--ref &lt;若当前设定大于 1 则乘以 2&gt; --bframes &lt;当前设定值 +=2&gt; --deblock 1:1 --psy-rd 0.4:&lt;跳过&gt; --aq-strength 0.6</code></li>
                    </ul>
                </li>
                <li><span class="text-blue-emph">fastdecode</span>降低解码算力占用以降低超高帧率 - 分辨率解码负载
                    <ul>
                        <li><code>--no-deblock --no-cabac --no-weightb --weightp 0</code></li>
                    </ul>
                </li>
                <li><span class="text-blue-emph">film</span>优化录像与电影场景画面
                    <ul>
                        <li><code>--deblock -1:-1 --psy-rd &lt;跳过&gt;:0.15</code></li>
                    </ul>
                </li>
                <li><span class="text-blue-emph">stillinage</span>优化静态图像画面
                    <ul>
                        <li><code>--deblock -3:-3 --psy-rd 2.0:0.7 --aq-strength 1.2</code></li>
                    </ul>
                </li>
                <li><span class="text-blue-emph">psnr</span>尽可能降低编码结果和原画的均方差 MSE 差异，但与画质关系不大
                    <ul>
                        <li><code>--aq-mode 0 --no-psy</code></li>
                    </ul>
                </li>
                <li><span class="text-blue-emph">ssim</span>比 <code>--tune psnr</code> 缓和一些
                    <ul>
                        <li><code>--aq-mode 2 --no-psy</code></li>
                    </ul>
                </li>
            </ul>

            <h2 id="h2-17">线程控制</h2>
            <h3>线程管理一</h3>
            <p>不同的算法和数据决定了不同的多线程优化性能。量化的步骤中，进程之间几乎不需要共享数据，进程占用和运算速度也不变；而冗余的步骤中则是反过来——占用可大可小，速度忽快忽慢，也需要进程间共享一定数据/内存。可以说如果想要让进程吃满更多核心，就得尽可能减少搜索冗余相关算法的强度。x264 编码器一共会占用 <code>--threads</code> 加 <code>--lookahead-threads</code>条进程。而 <code>--threads</code> 达到并超过 16~24 时，可以看到一定的画质下降，以及在更多核心的电脑上出现“吃不满”的问题，这就是 x264 中冗余算法的优化极限了。</p>
            <p>因此，设置创建比电脑处理器更多的线程只会从任务数量上冲淡如各个冗余步骤需要“等到之前步骤给出结果才能运行”的时间窗口，甚至有时等不到就跳过，导致码率增加，画质降低，得不偿失。</p>
            <p>x264 并没有对多路/多 CPU 节点电脑优化，但 <a href="../../x265-web-tutorial/HTML/index.html#h2-18">x265 使用线程池</a> 实现了。</p>
            <code class="code-bold">--threads</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数，建议保持默认（等于 CPU 线程）&gt;由于参考帧步骤要等其之前的步骤算完才开始，所以远超默认的值会因为处理器随机算的特性而降低参考帧的计算时间，使码率增加，画质降低，速度变慢</p>
            <code class="code-bold">--non-deterministic</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;开关，默认关，推荐开&gt; 降低多线程完算性——减少多线程共享数据的可靠性，些微提高画质。使用后每个进程的冗余判断更为独断，且让新的动态搜索线程得知「旧动态搜索线程线程实际搜素过，而非参数设定」的区域。「完算性」一般仅代表通过完整计算得到结果，而不是提前跳过的计算特征。而启用多线程，VBV 都会降低完算性</p>
            <code class="code-bold">--lookahead-threads</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数，建议保持默认（应该是 <code>--threads</code> 的 1/4）&gt;指定前瞻进程占用的线程数，速度太快则其后的编码进程跟不上，太慢则其后的编码进程要等结果，所以不需要改动</p>
            <code class="code-bold">--frame-threads</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数，建议保持默认（自动）&gt;指定 <code>--threads</code> 中分配多少线程给编码帧，决定一次同时编码多少帧（量化，优化，帧内预测，熵编码）。剩下则是上下游的处理（连续 B 帧推演，SEI，完算性错误管理），后者占用较少</p>
            <code class="code-bold">--sliced-threads</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;开关，默认关&gt;逐条带分配多线程。x264 r1607 前的多线程分配机制，后来因为问题太多而改成了逐帧分配多线程。剩下直播录屏等场景降低延迟一个用途</p>
            <ol class="font-monospace pl-5 text-smaller">
                <li>熵编码中，CABAC（见 <a href="../../x265-web-tutorial/HTML/index.html#h2-15">x265 教程 - 熵编码</a>）因为内容不连续所以经常重设，降低压缩率</li>
                <li>动态信息的动态矢量长度被限制到条带分片内部，干扰动态补偿，降低压缩率</li>
                <li>帧内冗余降级为条带内冗余，降低帧内编码压缩率</li>
                <li>增加了相当一部分（多余条带与 NAL 封包的）文件头</li>
                <li>大量条带的并行提高了编码单帧的速度，降低延迟</li>
            </ol>
            
            <h3>线程管理二</h3>
            <p>退一步讲，若能占满全部 CPU 核心，那么也算是实现了多线程优化。因此，关于“最大化利用 CPU 核心数量很多的电脑并提升画质”的平价方法就是多开几个编码，并限制每个编码占用的 CPU 线程数实现。例如 <a href="https://stackoverflow.com/questions/1449188/running-windows-batch-file-commands-asynchronously">Windows 批处理提供的 <code>START</code> 命令实现异步并行（多开些编码）</a>，搭配上述的 <code>--threads</code> 命令限制每个编码的进程数实现。</p>
            <p>x264/5 中，理论画质与性能最平衡的多线程数实际是 4，所以若设定 <code>--threads 4</code>，则 <code>--lookahead-threads</code> 等于 1。得到共 5 个线程占用。</p>

            <h3>线程管理三</h3>
            <p>此外还有一种难办的情况：游戏录屏。这会导致编码进程与其它进程争夺 CPU 或内存资源。后者可以通过升级内存解决，但前者不同的地方在于“多线程优化越好则越糟”——因为软件开发也遵循了“应该占满全部 CPU 核心”的逻辑，因此当 CPU 的算力或核心数没有超过两个程序占用加起来的峰值，就只能保护其中优先级较高的进程了。另一边，多人游戏的反作弊机制和防盗版机制的升级也增加了游戏对 CPU 和内存的压力。</p>
            <p>此时，“冗余”步骤的不稳定占用很可能会超出 CPU 算力极限导致卡顿（除非内存或散热不好，否则不会死机），因此要适当降低冗余强度来保证流畅（但需要一定经验并花费时间测试）。大多数人应对这种情况最简单的方案只有使用显卡或核显/SoC“附赠”的硬件视频编码器，或者购置高端些的视频采集卡两种方法实现；但如果 CPU 的算力足够同时流畅运行大型游戏和视频编码器，则可以参考附录：急用版 x264 教程配置 OBS 录屏的一些方案。</p>
            
            <h3>x264 内置滤镜</h3>
            <h4>降噪滤镜</h4>
            <code class="code-bold">--nr</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数 0~65536，降噪范围 100~1000，不推荐&gt;当 ABR/VBV 指定了高于 <code>--qpmax</code> 或默认最大量化强度时，会调用这个滤镜。如果有降噪需求则建议使用效果更好的外部滤镜工具，或至少使用 <code>--vf hqdn3d</code> 滤镜</p>

            <h4>AviSynth 滤镜</h4>
            <code class="code-bold">--vf</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;crop:[←],[↑],[→],[↓]/pad: [←],[↑],[→],[↓]/resize:[宽，高]，[变宽比]，[装盒]，[色度采样]，[缩放算法/select_every:步，帧，帧…]/hqdn3d:[空域 Y 降噪强度]，[空域 C 降噪强度]，[降噪时域 Y 强度]，[时域 C 降噪强度]/yadif[模式],[顺序]&gt;裁剪，加边，缩放/更改分辨率，删除/保留视频帧，降噪，色彩空间转换滤镜。例：</p>
            <ul class="font-monospace pl-5 text-smaller">
                <li><span class="text-blue-emph">crop:3,4,5,6</span>：视频左，上，右，下分别裁剪 3，4，5，6 个像素</li>
                <li><span class="text-blue-emph">pad:0,7,8,9,,,255,255,255</span>：视频上，右，下分别加 7，8，9 个像素的 #FFFFFF（白）边</li>
                <li><span class="text-blue-emph">pad:,,,,1920,1080,1,36,38</span>：视频对称加减边到 1920x1080 像素，若加边则加 #013638（深蓝绿）边</li>
                <li><span class="text-blue-emph">pad:,,,,3840,2160,,,</span>：视频加减边到 3840x2160 像素，若加边则加 #000000（黑）边</li>
                <li><span class="text-blue-emph">resize:1060,1080,96:53,,,lanczos</span>：1920x1080 视频的宽使用 lanczos 算法缩小 53/96；同时标记视频宽在播放时，宽度应拉伸 96:53 倍（96:53 长方像素），显示为 1920x1080</li>
                <li><span class="text-blue-emph">resize:1280,720,,i444,spline</span>：使用样条插值缩放输入视频到 1280x720，储存为 YCbCr 4:4:4</li>
                <li><span class="text-blue-emph">resize:1060,1080,,width,i420,lanczos</span>：使用 lanzcos 插值，只将宽 width 缩放到 1060px，储存为 YCbCr 4:2:0</li>
                <li><span class="text-blue-emph">hqdn3d:0,0,3,5</span>：仅开启时域降噪滤镜，分别在 Y，C 平面设定强度 3,5</li>
                <li><span class="text-blue-emph">vflip</span>：左右翻转视频</li>
                <li><span class="text-blue-emph">subtitles</span>：在集成 VSFilter64.dll 动态链接库的情况下渲染字幕文件，需<code>--sub</code> 导入字幕文件，然后使用 <code>--vf subtitles</code> 参数渲染字幕到视频</li>
                <li><span class="text-blue-emph">select_every:5,0,1,3,4</span>：视频每 8 帧中留第 1，2，4，5 帧，丢弃第 3 帧
                    <ul>
                        <li>AviSynth 中主要用于搭配 IVTC 滤镜使用，但 x264 中没有这些滤镜</li>
                    </ul>
                </li>
                <li><span class="text-blue-emph">yadif:1,tff</span>：使用 bobbing 算法，上场优先模式将交错视频转为逐行视频</li>
            </ul>
            <p>这些滤镜可以在实现简单的画面处理。使用多个滤镜的例子如：<code>--vf crop:10,0,10,0/resize:640,480,,,,lanczos</code>。</p>
            <ul>
                <li>resize 中 [select_every] 滤镜详见 <a href="http://avisynth.nl/index.php/Select#SelectEvery">AviSynth Wiki</a></li>
                <li>resize 中 [色彩空间] 可用的值有：i400,i420,yv12,nv12,nv21,i422,yv16,nv16,yuyv,uyvy,i444,yv24,bgr,bgra,rgb</li>
                <li>resize 中 [缩放算法] 可用的值有：fastbilinear,bilinear,bicubic,experimental,point,area,bicublin,gauss,sinc,lanczos,spline</li>
                <li>yadif 是一种简单的交错转逐行滤镜，推荐用画质更好的外部滤镜，见附录 ε：<a href="../../deint-ivtc-web-tutorial/HTML/index.html">交错转逐行与 IVTC</a></li>
                <li>x264 中内置的 yadif 滤镜来自 MPlayer，因此参数不同于 AviSynth：
                    <ul>
                        <li>yadif 中 [模式] 可用的值有 0,1,2,3；[顺序] 可用的值有 tff 和 bff</li>
                    </ul>
                </li>
                <li>hdqn3d 是一种简单快速的时域 + 空域降噪滤镜。仅指定 <code>--vf hqdn3d</code> 则使用默认强度（仅开启滤镜）为 4,3,6,4.5</li>
            </ul>
            <code class="code-bold">--sub</code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;路径到文件，<span class="text-red-emph">需 <code>--vf subtitles</code> 和 VSFilter64.dll</span>&gt;导入字幕文件，</p>

            <h2 id="h2-18">工具下载</h2>
            <h3>套壳 x264/libx264 的 GUI 编码压制软件</h3>
            <p>并没有特别好的选择。尤其是当能够使用 CLI 参数命令 ffmpeg.exe，x264.exe 后。</p>
            <table class="table-center">
                <tbody>
                    <tr class="border-bottom">
                        <th class="t-light-gray"><a href="https://shana.pe.kr/shanaencoder_download">Shana<br>Encoder</a></th>
                        <td class="px-1 text-smaller">ffmpeg-CLI 搭配部分 GUI，上手较慢。使用了 ffmpeg 内嵌的 libx264，libx265，NVEnc</td>
                        <td style="max-width: 22rem;">
                                <img src="files/tools-download/shana-encoder.png" alt="shana-encoder" class=""><br>
                                <img src="files/tools-download/shana-encoder-1.png" alt="shana-encoder-1" class="">
                        </td>
                    </tr>
                    <tr class="border-bottom">
                        <th class="t-light-gray"><a href="https://bitbucket.org/muldersoft/simple-x264-launcher/downloads/">Simple x264 Launcher</a></th>
                        <td class="px-1 text-smaller">内嵌 AviSynth，支持便携版 VapourSynth，额外支持 x265 和 NVEnc 编码器，适合批量压制</td>
                        <td style="max-width: 22rem;"><img src="files/tools-download/simple-x264-launcher.png" alt="simple-x264-launcher" class=""></td>
                    </tr>
                    <tr>
                        <th class="t-light-gray">小丸工具箱</th>
                        <td class="px-1 text-smaller">操作简单，适合入门的中文软件。网上能搜到详细教程。内嵌 MediaInfo，mp4box，Mkvtoolnix<br>镜像：<a href="https://pan.baidu.com/s/1VHonGHoZ0DmQBNZaRjML2A&pwd=crhu">百度云</a> 提取码"crhu"</td>
                        <td style="max-width: 22rem;"><img src="files/tools-download/xiaowan-toolbox.png" alt="xiaowan-toolbox" class=""></td>
                    </tr>
                </tbody>
            </table>
            
            <h3>基本工具</h3>
            <table class="table-center">
                <tbody>
                    <tr class="border-bottom">
                        <th class="t-light-gray"><a href="http://ffmpeg.org/download.html">ffmpeg</a></th>
                        <td class="px-1 text-smaller">强大的 CLI 开源视音频处理工具。几乎所有的视音频处理都绕不开</td>
                        <td style="max-width: 22rem;"> </td>
                    </tr>
                    <tr class="border-bottom">
                        <th class="t-light-gray"><a href="https://mpv.io/installation/">mpv</a></th>
                        <td class="px-1 text-smaller">开源，支持便携的现代视频播放器。见 <a href="https://nazorip.site/archives/1052/">安装与配置</a>教程</td>
                        <td style="max-width: 22rem;">
                            <img src="files/tools-download/mpv.png" alt="mpv" class="">
                        </td>
                    </tr>
                    <tr class="border-bottom">
                        <th class="t-light-gray"><a href="https://www.voukoder.org/">Voukoder</a></th>
                        <td class="px-1 text-smaller">开源 Premiere Vegas After Effects 压制导出插件，分为 Voukoder 和 V-Connector 两部分</td>
                        <td style="max-width: 22rem;">
                            <img src="files/tools-download/voukoder.png" alt="voukoder" class="">
                        </td>
                    </tr>
                    <tr class="border-bottom">
                        <th class="t-light-gray"><a href="https://obsproject.com/zh-cn/download">OBS</a></th>
                        <td class="px-1 text-smaller">强大的开源直播框架和软件，设置略比传统录屏软件复杂，但效果也更好</td>
                        <td style="max-width: 22rem;">
                            <img src="files/tools-download/obs.png" alt="obs" class="">
                        </td>
                    </tr>
                    <tr class="border-bottom">
                        <th class="t-light-gray"><a href="https://mediaarea.net/zh-CN/MediaInfo">MediaInfo</a></th>
                        <td class="px-1 text-smaller">开源的 GUI 媒体元数据/视音频格式读取器，用于配置正确的压制参数</td>
                        <td style="max-width: 22rem;">
                            <img src="files/tools-download/mediainfo.png" alt="mediainfo" class=""><br>
                            <img src="files/tools-download/mediainfo-1.png" alt="mediainfo-1" class="">
                        </td>
                    </tr>
                    <tr>
                        <th class="t-light-gray"><a href="http://ffmpeg.org/download.html">ffprobe</a></th>
                        <td class="px-1 text-smaller">CLI 视音频格式读取器，若检测所得信息与 MediaInfo 所异，则优先参考 ffprobe<br>见<a href="https://nazorip.site/archives/169/">基本使用</a>，以及<a href="https://nazorip.site/archives/1068/">搭配 Excel 的视频数据可视化</a>教程
                        </td>
                        <td style="max-width: 22rem;"> </td>
                    </tr>
                </tbody>
            </table>

            <h3>x264 本体</h3>
            <table>
                <tbody>
                    <tr class="border-bottom">
                        <th class="px-3 t-light-gray"><a href="https://www.mediafire.com/folder/arv5xmdqyiczc">Patman</a></th>
                        <td class="px-1">支持 FFMS2 Lavf 编解码 [8~10bit]</td>
                    </tr>
                    <tr class="border-bottom">
                        <th class="px-3 t-light-gray"><a href="https://www.mediafire.com/?bxvu1vvld31k1">LigH</a></th>
                        <td class="px-1">支持 FFMS2 Lavf 编解码 [8~10bit]</td>
                    </tr>
                    <tr class="border-bottom">
                        <th class="px-3 t-light-gray"><a href="https://github.com/jpsdr/x264/releases/">jspdr (tMod)</a></th>
                        <td class="px-1">支持 FFMS2 Lavf 编解码，MCF 线程管理库</td>
                    </tr>
                    <tr>
                        <th class="px-3 t-light-gray">x264 7mod</th>
                        <td class="px-1">支持 FFMS2 Lavf 编解码，支持 hqdn3d 降噪，镜像链接：<a href="https://drive.google.com/drive/folders/1kFCeNGA_wiiLt-DSeI3cyY8vxlffgQcy?usp=sharing">谷歌盘</a>/<a href="https://pan.baidu.com/s/1sbz8WztGTz3lcLzirHW_2w">百度云</a></td>
                    </tr>
                    <tr>
                        <th class="px-3 t-light-gray"><a href="http://komisar.gin.by/">Komisar KMod</a></th>
                        <td class="px-1">支持 FFMS2 编解码 [8][10]bit</td>
                    </tr>
                </tbody>
            </table>

            <h4>视频编码后偏色的各种原因</h4>
            <button type="button" class="collapsible border-main rounded-3">点击展开/折叠内容</button>
            <div class="coll-content">
                <p>将编码前后的视频窗口至于同屏下，使用截图软件截图，再使用取色器测量特定区域的颜色：</p>
                <ul>
                    <li><b>偏黄：</b>
                        Bt.709，Bt.2020 源被转换成了 Bt.601。可以通过 <code>colormatrix=源矩阵:目标矩阵</code> 参数转换一段原视频做测试复现：<br>
                        <code>ffmpeg.exe -i "偏色前.mp4" -vf "colormatrix=bt709:bt601" -c:v libx264 -c:a copy -c:s copy "D:\Desktop\转601.mkv"</code>
                    </li>
                    <li><b>偏绿：</b>
                        使用了英伟达 NVDEC 硬件解码器导致的颜色错误，目前已知 RTX 3000 系显卡有。见 <a href="https://nazorip.site/archives/1052/">MPV 播放器</a> 中的类似状况
                    </li>
                    <li><b>对比度过低（1）：</b>
                        编码器设定输入位深为 8bit，源视频为 10bit 或更高，没有滤镜工具转换源到 8bit，直接编码后可能导致
                    </li>
                    <li><b>对比度过低（2）：</b>
                        编码器设定输入色域为完整 Full，视频为有限色域 Limited，没有滤镜工具转换源到完整色域，直接编码后可能导致
                    </li>
                </ul>
            </div>

            <h4>ffmpeg 色深转换处理</h4>
            <button type="button" class="collapsible border-main rounded-3 mb-3">点击展开/折叠内容</button>
            <div class="coll-content">
                <p>ffmpeg 转换到完整：</p>
                <code>ffmpeg.exe -i "limited.mp4" -vf "scale=in_range=limited:out_range=full" -color_range 2 -pix_fmt yuv420p -movflags +write_colr "full.mp4"</code>
                <p>ffmpeg 转换到有限：</p>
                <code>ffmpeg.exe -i "limited.mp4" -vf "scale=in_range=full:out_range=limited" -color_range 1 -pix_fmt yuv420p -movflags +write_colr "full.mp4"</code>
                <ul>
                    <li><code>"scale=in_range=limited:out_range=full</code> 代表输入和输出的范围</li>
                    <li><code>-color_range</code> 选择编码和封装的色深密度（0~2）</li>
                    <li><code>-movflags +write_colr</code> 在 .mp4 封装下写入色深密度元数据</li>
                </ul>
            </div>
        </div>
        <footer class="py-3 my-4 align-items-center border-top">
            <p>联系：
                <a href='https://github.com/iAvoe/'>Github</a>，
                <a href='https://jq.qq.com/?_wv=1027&k=5YJFXyf'>QQ 群：691892901</a>
            </p>
            &#x24B8; iAvoe，2024
        </footer>
	</body>
</html>